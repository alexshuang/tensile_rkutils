#!/usr/bin/env python3


import argparse
import json
import os
import pdb
#import numpy as np
#import pandas as pd
from pathlib import Path
from functools import partial

cur_tab = 0


def get_max_dim_size(problem_sizes):
    max_size = 0
    for p in problem_sizes:
        for o in p:
            if max_size < o:
                max_size = o
    return max_size


def do_perf(problem_sizes, thory_gflops):
    max_dim_size = get_max_dim_size(problem_sizes)
    kernel, m, n, c, k, gflops, efficiency = [], [], [], [], [], [], []
    for p in problem_sizes:
        print("pef problem size: " + ', '.join(str(o) for o in p))
        m_, n_, c_, k_ = p[:4]
        ps_cmd = "sed -i \'/.*problemSizes\[/,/}};/s/{.*}};/{" + ', '.join(str(o) for o in p) + "}};/g\' ../source/ClientParameters.h"
        ms_cmd = "sed -i \'s/\(.*maxSize. = \).*/\\1" + str(max_dim_size**2) + ";/g\' ../source/ClientParameters.h"
        cc_cmd = "cmake --build . --config Release -- -j 8"
        perf_cmd = "./client --platform-idx 0 --device-idx 0 --init-alpha 1 --init-beta 0 --init-d 0 --init-c 0 --init-a 3 --init-b 3 --c-equal-d 1 --print-valids 0 --print-max 4 --num-benchmarks 20 --num-elements-to-validate 0 --num-enqueues-per-sync 1 --num-syncs-per-benchmark 1 --use-gpu-timer 1 --sleep-percent 200 --benchmark-solutions 0"
        m.append(m_)
        n.append(n_)
        c.append(c_)
        k.append(k_)
        ret = os.system(ps_cmd)
        if ret != 0:
            print("ERROR: Fail to set problem size: " + ps_cmd)
            exit(ret)
        ret = os.system(ms_cmd)
        if ret != 0:
            print("ERROR: Fail to set maxSize of A/B/C/D: " + ms_cmd)
            exit(ret)
        ret = os.system(cc_cmd)
        if ret != 0:
            exit(ret)
        gflops_ = []
        kernel_name = None
        for _ in range(1):
            res = os.popen(perf_cmd).readlines()[-1].split(' ')
            gflops_.append(float(res[1]))
            if kernel_name == None:
                kernel_name = res[-1].strip()
        gflops_max = max(gflops_)
        print(gflops_)
        print(gflops_max)
        gflops.append(gflops_max)
        efficiency.append(gflops_max / float(thory_gflops) * 100)
        kernel.append(kernel_name)
    return (kernel, m, n, c, k, gflops, efficiency)


def save_file(data):
    kernel, m, n, c, k, gflops, efficiency = data
    df = pd.DataFrame()
    #df['KernelName'] = np.array(kernel)
    df['M'] = np.array(m)
    df['N'] = np.array(n)
    df['C'] = np.array(c)
    df['K'] = np.array(k)
    df['GFlops'] = np.array(gflops)
    df['Efficiency'] = np.array(efficiency)
    fname = kernel[0] + '.csv'
    print("perf resoult save as " + fname)
    df.to_csv(fname, index=False)


def write_line(fp, s='', cmt='', tab=0):
    pre_s = '  ' * tab
    if cmt != '':
        if not cmt.startswith('//'):
            cmt = '// ' + cmt
        cmt = '\t\t' + cmt
    fp.write(pre_s + s + cmt + '\n')


def write_comments(fp, s, bar=False, bar_len=40, nl=False, tab=0):
    pre_s = '  ' * tab
    if bar:
        bar_s = pre_s + '/' + '*' * bar_len + '/\n'
    s = pre_s + '/* ' + s + ' */\n' if bar else pre_s + '// ' + s + '\n'
    if bar:
        fp.write(bar_s)
    fp.write(s)
    if bar:
        fp.write(bar_s)
    if nl:
        fp.write('\n')


def def_var(fp, name, val, cmt='', nl=False):
    val = str(val)
    write_line(fp, 'var ' + name + ' = ' + val, cmt)
    if nl:
        write_line(fp)


def def_regs(conf, fp):
    for k in ['sregs', 'vregs']:
        write_line(fp, "// %s define" % k)
        for k, v in conf[k].items():
            def_var(fp, k, v)
        write_line(fp)

    write_comments(fp, '2GB limit - set offsets to -1 to exceed this and clamp')
    def_var(fp, 'BufferLimit', 0x80000000, nl=True)
    write_comments(fp, 'Bits 127:96 of SRD.  Set DataFormat = 32 bit')
    def_var(fp, 'Srd127_96', 0x20000, nl=True)
    def_var(fp, 'roundMaskVal', 0xffff0000, nl=True)


def def_lds_vars(conf, fp):
    # calc index per thread
    pad = conf['mfma']['pad']
    mt_h = conf['mt']['h']
    mt_w = conf['mt']['w']
    simd = conf['mfma']['simd']
    a_per_wr = 256 + pad
    lvca = int(32 / (conf['glvw'] * 2))
    rows_per_wave = int(mt_h / simd)
    a_vw = int(rows_per_wave / (64 / lvca))
    a_per_wave = a_per_wr * a_vw
    a_per_wg = a_per_wave * simd
    b_per_wr = 256 + pad
    lvcb = int(32 / (conf['glvw'] * 2))
    cols_per_wave = int(mt_w / simd)
    b_vw = int(cols_per_wave / (64 / lvcb))
    b_per_wave = b_per_wr * b_vw
    b_per_wg = b_per_wave * simd

    write_line(fp, "// lds vars define")
    def_var(fp, 'varlds_pad', pad)
    def_var(fp, 'varlds_Asize_per_wr', a_per_wr, '256 + varlds_pad')
    def_var(fp, 'varlds_Asize_per_wave', 'varlds_Asize_per_wr * %d' % a_vw, 'vw == %d' % a_vw)
    def_var(fp, 'varlds_Asize_per_wg', 'varlds_Asize_per_wave * %d' % simd)
    write_line(fp)
    def_var(fp, 'varlds_Bsize_per_wr', b_per_wr, '256 + varlds_pad')
    def_var(fp, 'varlds_Bsize_per_wave', 'varlds_Bsize_per_wr * %d' % b_vw, 'vw == %d' % b_vw)
    def_var(fp, 'varlds_Bsize_per_wg', 'varlds_Bsize_per_wave * %d' % simd)
    write_line(fp)
    def_var(fp, 'varA_lds_base_addr', 0)
    def_var(fp, 'varB_lds_base_addr', 'varA_lds_base_addr + varlds_Asize_per_wg * 2')
    write_line(fp)

    conf['lvca'] = lvca
    conf['lvcb'] = lvcb
    conf['A_VW'] = a_vw
    conf['B_VW'] = b_vw
    conf['varlds_Asize_per_wr'] = a_per_wr
    conf['varlds_Asize_per_wave'] = a_per_wave
    conf['varlds_Asize_per_wg'] = a_per_wg
    conf['varlds_Bsize_per_wr'] = b_per_wr
    conf['varlds_Bsize_per_wave'] = b_per_wave
    conf['varlds_Bsize_per_wg'] = b_per_wg


def def_header(conf, fp):
    write_line(fp, '\nshader main')
    write_line(fp, 'type(CS)', tab=1)
    write_line(fp, 'user_sgpr_count(14)', tab=1)
    write_line(fp, 'tgid_x_en(1)', tab=1)
    write_line(fp, 'tgid_y_en(1)', tab=1)
    write_line(fp, 'tgid_z_en(1)', tab=1)
    write_line(fp, 'tidig_comp_cnt(2)', tab=1)
    write_line(fp)


def def_foot(conf, fp):
    write_line(fp, 'label_end:')
    write_line(fp, 's_waitcnt 0', tab=1)
    write_line(fp, 's_endpgm', tab=1)
    write_line(fp)
    write_line(fp, 'end')
    write_line(fp)


def reg_str(s, start_off=0, end_off=0):
    if isinstance(s, str) and (s.startswith('v[') or s.startswith('s[')):
        return s
    if isinstance(s, int) or (isinstance(s, str) and s[0].isdigit()):
        return s
    if isinstance(s, tuple):
        s, *off = s
        start_off = off[0]
        if len(off) > 1: end_off = off[1]
    if not s.startswith('vgpr') and not s.startswith('sgpr'):
        return s
    dtype = 'v' if s.startswith('vgpr') else 's'
    if end_off != 0: 
        s = '%s+%s:%s+%s' % (s, start_off, s, end_off)
    elif start_off != 0:
        s = '%s+%s' % (s, start_off)
    return dtype + '[' + s + ']'


def s_load(fp, sgpr, src, off, dw=1):
    s = 's_load_dword%s %s, %s, 0x%x' % ('x' + str(dw) if dw > 1 else '',
            reg_str(sgpr, end_off=(dw - 1)),
            reg_str(src, end_off=1), off)
    write_line(fp, s, tab=1)


# load kernel args to sgpr
def load_karg(conf, fp, var, dw=1):
    s_load(fp, var, 'sgprKernArgAddress', conf['kargs'][var], dw=dw)
    return var


def v_mask(fp, dest, src, subgrp_sz, dtype='b32', tab=1):
    vop2_instr(fp, 'and', dtype, dest, src, subgrp_sz, tab=tab)


def set_lds_addr(fp, addr, tab=1):
    s_mov(fp, 'm0', addr)
    write_line(fp)


def var_str(*s):
    return '+'.join(str(o) for o in s)


def read_hwreg(fp, dest, src):
    sop1_sopk_instr(fp, 'getreg', 'b32', dest, 'hwreg(' + src + ')')

    
def get_thread_info(conf, fp):
    #vgprSerial    holds threadIdx
    #vgprSerial+1  holds WaveFrontId (0-63)
    #vgprSerial+2  holds threadIdy  (simd= 0,1,2,3)
    #vgprSerial+3  holds threadIdZ  (wave0 =0 wave1 = 1)
    tid = 'vgprSerial'
    wf_tid = var_str(tid, 1)
    simd_id = var_str(tid, 2)
    wave_id = var_str(tid, 3)

    v_mov(fp, tid, 'v0')
    v_mask(fp, wf_tid, tid, 64) # wave front id

    #HW_ID_REG
    #bit[0-3] #waveId
    #bit[5-4] #simdId
    #bit[11-8] #CuId
    hwid = 'sgprHWID'
    read_hwreg(fp, hwid, 'HW_REG_HW_ID')
    v_mask(fp, 'v4', '0x30', hwid)  # simd
    v_lshr(fp, simd_id, 4, 'v4')
    v_mask(fp, wave_id, '0xf', hwid) # waveid

    conf['vTID'] = tid
    conf['vWFTID'] = wf_tid
    conf['vSIMDID'] = simd_id
    conf['vWaveID'] = wave_id

    write_line(fp)


def vgpr2sgpr(fp, dest, src, tab=1):
    write_line(fp, 'v_readfirstlane_b32\t%s, %s' % (reg_str(dest), reg_str(src)), tab=tab)


def create_branch(fp, label, var, val, tab=1, eq=False):
    tmp = 'sgprHWID+1'
    wid = vgpr2sgpr(fp, tmp, var)
    write_line(fp, 's_cmp_eq_u32\t%s, %d' % (reg_str(tmp), val), tab=tab)
    cmp_instr = 's_cbranch_scc1' if eq else 's_cbranch_scc0'
    write_line(fp, '%s\t%s' % (cmp_instr, label), tab=tab)
    write_line(fp)


def s_waitcnt(fp, cnt, itype=None, tab=1, nl=False):
    s = '%scnt(%d)' % (itype, cnt) if itype else str(cnt)
    write_line(fp, 's_waitcnt\t%s' % s, tab=tab)
    if nl:
        write_line(fp)


def sopc_instr(fp, src0, src1, op, dtype, tab=1):
    src0, src1 = reg_str(src0), reg_str(src1)
    write_line(fp, 's_cmp_%s_%s\t%s, %s' % (op, dtype, src0, src1), tab=tab)


def sop1_sopk_instr(fp, cmd, dtype, dest, src, tab=1):
    dest, src = reg_str(dest), reg_str(src)
    write_line(fp, 's_%s_%s\t%s, %s' % (cmd, dtype, dest, src), tab=tab)


def sop2_instr(fp, cmd, dtype, dest, src0, src1, tab=1):
    dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
    write_line(fp, 's_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
        src1), tab=tab)


def s_mov(fp, dest, src, dtype='b32', tab=1, nl=False):
    sop1_sopk_instr(fp, 'mov', dtype, dest, src, tab=tab)
    if nl:
        write_line(fp)


def s_sub(fp, dest, src0, src1, dtype='i32', tab=1, nl=False):
    sop2_instr(fp, 'sub', dtype, dest, src0, src1, tab=tab)
    if nl:
        write_line(fp)


def s_mul(fp, dest, src0, src1, dtype='i32', tab=1, nl=False):
    sop2_instr(fp, 'mul', dtype, dest, src0, src1, tab=tab)
    if nl:
        write_line(fp)


def s_lsh(fp, dest, src0, src1, ldir=True, dtype='b32', tab=1, nl=False):
    sop2_instr(fp, 'lshl' if ldir else 'lshr', dtype, dest, src0, src1, tab=tab)
    if nl:
        write_line(fp)


def s_lshl(fp, dest, src0, src1, dtype='b32', tab=1, nl=False):
    s_lsh(fp, dest, src0, src1, dtype=dtype, ldir=True, tab=tab, nl=nl)


def s_lshr(fp, dest, src0, src1, dtype='b32', tab=1, nl=False):
    s_lsh(fp, dest, src0, src1, dtype=dtype, ldir=False, tab=tab, nl=nl)


def s_add(fp, dest, src0, src1, carry_out=False, dtype='i32', tab=1, nl=False):
    sop2_instr(fp, 'addc' if carry_out else 'add', dtype, dest, src0, src1, tab=tab)
    if nl:
        write_line(fp)


def s_cmp(fp, src0, src1, op='eq', dtype='u32', tab=1, nl=False):
    src0, src1 = reg_str(src0), reg_str(src1)
    sopc_instr(fp, src0, src1, op, dtype, tab=tab)
    if nl:
        write_line(fp)


def set_addr_desc(fp, mat, tab=1):
    '''
    WorkgroupId agnostic address calculation
    s[workGroup0] provides MT0 tile number  that this workgroup working
    s[workGroup1] provides MT1 tile number that this workgroup working
     use tle number to generate start address of the tile that this workgroup allocated too

    Global read addresses: address A resource descriptor set-up
    sgpr[0-1] - base address
    sgpr[2]   - limit
    sgpr[3]   - attributes

    calculate base address for  A
    1. multiply MT0 size with TileNumber passed in s[sgprWorkGroup0]
    2. multiply [1] result with stride[0] store result into 64-bit
    3. the above two steps gives starting address of tile that this workgroup working
    '''
    src = 'sgprAddress' + mat
    dest = 'sgprSrd' + mat
    s_mov(fp, dest, src)
    # (dest, 1) == dest+1
    s_mov(fp, (dest, 1), (src, 1))
    '''
    s_mov(fp, 'sgprShadowLimitA', 'sgprTensor2dSizeA', 'u32')
    s_mov(fp, 'sgprShadowLimitA+1', 'sgprTensor2dSizeA', 'u32')
    # convert to bytes
    s_lsh(fp, 'sgprShadowLimitA', 'sgprShadowLimitA', 1, ldir=True, dtype='b64')
    # pad by 4
    s_add(fp, 'sgprShadowLimitA', 'sgprShadowLimitA', 4, dtype='u32')
    s_add(fp, 'sgprShadowLimitA+1', 'sgprShadowLimitA+1', 0, carry_out=True, dtype='u32')
    s_cmp(fp, 'sgprShadowLimitA+1', 0)
    s_cselect(fp, 'sgprSrdA+2', 'sgprShadowLimitA', 'BufferLimit')
    '''
    s_mov(fp, (dest, 2), 'BufferLimit')
    s_mov(fp, (dest, 3), 'Srd127_96')
    write_line(fp)


def vop1_instr(fp, cmd, dtype, dest, src, tab=1):
    dest, src = reg_str(dest), reg_str(src)
    write_line(fp, 'v_%s_%s\t%s, %s' % (cmd, dtype, dest, src), tab=tab)


def vop2_instr(fp, cmd, dtype, dest, src0, src1, tab=1):
    dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
    write_line(fp, 'v_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
        src1), tab=tab)


def v_lsh(fp, dest, src0, src1, dtype, ldir, tab=1, nl=False):
    vop2_instr(fp, 'lshlrev' if ldir else 'lshrrev', dtype, dest, src0, src1, tab=tab)
    if nl:
        write_line(fp)


def v_lshl(fp, dest, src0, src1, dtype='b32', tab=1, nl=False):
    v_lsh(fp, dest, src0, src1, dtype=dtype, ldir=True, tab=tab, nl=nl)


def v_lshr(fp, dest, src0, src1, dtype='b32', tab=1, nl=False):
    v_lsh(fp, dest, src0, src1, dtype=dtype, ldir=False, tab=tab, nl=nl)


def v_mov(fp, dest, src, dtype='b32', tab=1):
    vop1_instr(fp, 'mov', dtype, dest, src, tab=tab)


def v_add(fp, dest, src0, src1, carry_out=False, dtype='i32', tab=1, nl=False):
    if carry_out == False:
        vop2_instr(fp, 'add', dtype, dest, src0, src1, tab=tab)
    else:
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        write_line(fp, 'v_add_co_%s\t%s, vcc, %s, %s' % (dtype, dest, src0,
            src1), tab=tab)
    if nl:
        write_line(fp)


def v_mul(fp, dest, src0, src1, dtype='i32', tab=1, nl=False):
    vop2_instr(fp, 'mul_lo', dtype, dest, src0, src1, tab=tab)
    if nl:
        write_line(fp)


def to_shift_bit(val):
    b, s = 0, 1
    while s < val:
        s *= 2
        b += 1
    return b


def cvt2bytes(fp, var):
    # address elements to bytes
    v_lshl(fp, var, 1, var)


def global_address_assignment(conf, fp, mat):
    write_comments(fp, 'global address of %s' % mat, tab=1)

    # set address A descriptor
    set_addr_desc(fp, mat)

    dest = 'sgprLocalWriteAddr' + mat
    src = 'vgprGlobalReadOfvar' + mat
    off = 'sgprScalarGlobalReadOffset' + mat
    mat_stride = 'sgprStrides' + mat
    vw = conf[mat + '_VW']

    # start read address of wave
    mt = conf['mt']['h'] if mat == 'A' else conf['mt']['w']
    s_mul(fp, 's84', mat_stride, mt)
    s_mul(fp, 's84', 'sgprWorkGroup0', 's84')
    vgpr2sgpr(fp, 'sgprFetchSubGrpId', conf['vSIMDID'])
    s_mul(fp, 's85', mat_stride, int(mt / conf['mfma']['simd']))
    s_mul(fp, 's85', 'sgprFetchSubGrpId', 's85') # handle 16 rows per subgrp(wave)
    s_add(fp, 's84', 's84', 's85')

    write_line(fp)

    # tile offset assignment
    tid = conf['vWFTID']
    glvw = conf['glvw']
    lvca = conf['lvca']
    write_comments(fp, 'LVCA=%d, vw=-1' % lvca, tab=1)
    v_lshr(fp, 'v0', to_shift_bit(lvca), tid)
    v_mul(fp, 'v4', mat_stride, 'v0', dtype='u32')
    v_mask(fp, 'v1', lvca - 1, tid)
    cvt2bytes(fp, 'v1')
    v_add(fp, src, 'v4', 'v1', dtype='u32', carry_out=True)
    v_add(fp, src, src, 's84', dtype='u32')
    cvt2bytes(fp, src)

    write_line(fp)

    s_lshl(fp, off, mat_stride, 3) # 4 lines * 2 bytes per element
    s_sub(fp, off, off, 'varlds_%ssize_per_wr' % mat, dtype='u32')
    '''
    for i in range(1, vw + 1):
        v_add(fp, (src, i), off, (src, i - 1), dtype='u32')
    '''
    for_loop(vw, partial(v_add, fp, var_str(src, 'i'), off,
        var_str(src, 'i-1'), dtype='u32'), start=1)
    write_line(fp)
    
    write_comments(fp, 'global memory to lds address', tab=1)
    s_mov(fp, dest, 'varlds_%ssize_per_wave' % mat)
    s_mul(fp, dest, 'sgprFetchSubGrpId', dest)
    s_add(fp, dest, dest, 'var%s_lds_base_addr' % mat, dtype='i32')
    write_line(fp)


def s_barrier(fp, val=0, nl=False):
    write_line(fp, 's_barrier', tab=1)
    if nl:
        write_line(fp)


def s_setprio(fp, prio, nl=False):
    write_line(fp, 's_setprio %d' % prio, tab=1)
    if nl:
        write_line(fp)


def lo2hi(fp, var):
    # copy var to var+1
    dest = var_str(var, 1)
    s_mov(fp, dest, var)
    return dest


def buffer_load(fp, dest, off, src_desc, dw=1, lds=0, offset=None, tab=1, nl=False):
    dest, off, src_desc = reg_str(dest), reg_str(off), reg_str(src_desc, end_off=3)
    s = 'buffer_load_dword%s %s, %s, %s, %s' % ('x' + str(dw) if dw > 1 else '',
            dest, off, src_desc, '0 offen:1 lds:%d offset:%s' % (lds, offset))
    write_line(fp, s, tab=tab)
    if nl:
        write_line(fp)


def fetch2lds(conf, fp, mat, base, k=32, it=1):
    write_comments(fp, 'fetch %s to lds, %d iterations' % (mat, it), bar=True, tab=1)

    dest = 'vgprG2L' + mat
    off = 'vgprGlobalReadOfvar' + mat
    src_desc = 'sgprSrd' + mat
    vw = conf[mat + '_VW']
    wr_sz = 'varlds_%ssize_per_wr' % mat

    '''
    for i in range(it):
        set_lds_addr(fp, addr)
        for i in range(vw):
            offset = '%s * %d' % (wr_sz, i)
            buffer_load(fp, (dest, i), (off, i), (src_desc, 0, 3), lds=1, offset=offset)
        # update off to next iteration 
        for i in range(vw):
            v_add(fp, (off, i), 64, (off, i))
        #update lds addr
        s_add(fp, addr, addr, it_sz)
        write_line(fp)
    '''
    for i in range(it):
        set_lds_addr(fp, base)
        
        func = partial(buffer_load, fp, var_str(dest, 'i'), var_str(off, 'i'),
                src_desc, lds=1, offset='%s * i' % wr_sz)
        for_loop(vw, func)
        # update off to next iteration 
        func = partial(v_add, fp, var_str(off, 'i'), 64, var_str(off, 'i'))
        for_loop(vw, func)
    write_line(fp)


def wait4fetch(fp, wf_prio=0, tab=1):
    vwA = conf['A_VW']
    vwB = conf['B_VW']

    # wait for A[0]
    s_waitcnt(fp, 2 * vwB + vwA, 'vm')
    if wf_prio > 0:
        s_setprio(fp, wf_prio)
    s_barrier(fp) 
    s_setprio(fp, 0)

    # wait for B[0]
    s_waitcnt(fp, vwB + vwA, 'vm')
    if wf_prio > 0:
        s_setprio(fp, wf_prio)
    s_barrier(fp)
    s_setprio(fp, 0)
    write_line(fp)


def s_cbranch(fp, label, eq=True, tab=1, nl=True):
    write_line(fp, 's_cbranch_scc%d\t%s' % (eq, label), tab=1)
    if nl:
        write_line(fp)


def do_fetch(conf, fp):
    baseA1 = 'sgprLocalWriteAddrA'
    baseA2 = 'sgprLocalWriteAddrA+1'
    baseB1 = 'sgprLocalWriteAddrB'
    baseB2 = 'sgprLocalWriteAddrB+1'
    s_add(fp, baseA2, baseA1, 'varlds_Asize_per_wg', dtype='u32')
    s_add(fp, baseB2, baseB1, 'varlds_Bsize_per_wg', dtype='u32')
    prefetch = conf['prefetch']
    vwA = conf['A_VW']
    vwB = conf['B_VW']

    if prefetch:
        fetch2lds(conf, fp, 'A', baseA1)
        fetch2lds(conf, fp, 'B', baseB1)
        fetch2lds(conf, fp, 'A', baseA2)
        fetch2lds(conf, fp, 'B', baseB2)
        wait4fetch(fp)

    lcnt = 'sgprLoopCounters'
    s_lshr(fp, lcnt, 'sgprSizesSum', 5) # k=32
    s_sub(fp, lcnt, 0, lcnt)
    if prefetch:
        s_add(fp, lcnt, 2, lcnt, dtype='i32')
    write_line(fp)

    write_line(fp, 'unroll_fetch:')

    fetch2lds(conf, fp, 'A', baseA1)
    fetch2lds(conf, fp, 'B', baseB1)
    wait4fetch(fp, 1)
    s_add(fp, lcnt, 1, lcnt, dtype='u32')
    write_line(fp)

    fetch2lds(conf, fp, 'A', baseA2)
    fetch2lds(conf, fp, 'B', baseB2)
    wait4fetch(fp, 1)
    s_add(fp, lcnt, 1, lcnt, dtype='u32')
    write_line(fp)

    s_cmp(fp, 'sgprLoopCounters', 0, dtype='i32')
    s_cbranch(fp, 'unroll_fetch', eq=False)
    write_line(fp)

    write_line(fp, 'finish_fetch:')
    s_waitcnt(fp, 8, itype='vm')
    s_barrier(fp)
    s_waitcnt(fp, 0, itype='vm')
    s_barrier(fp)
    write_line(fp, 's_endpgm')
    write_line(fp)


def def_fetch(conf, fp):
    # load A/B address, stridesA/B, sgprTensor2dSizeA/B, size L
    addrA = load_karg(conf, fp, 'sgprAddressA', 4)
    addrB = addrA + '+2'
    strideA = load_karg(conf, fp, 'sgprStridesA', 4)
    strideB = strideA + '+2'
    t2d_sizeA = load_karg(conf, fp, 'sgprTensor2dSizeA', 4)
    t2d_sizeB = t2d_sizeA + '+2'
    size_sum = load_karg(conf, fp, 'sgprSizesSum')
    write_line(fp)

    # clamp lds size to 0x3000
    set_lds_addr(fp, 0x3000)

    get_thread_info(conf, fp)

    create_branch(fp, 'wave0_MAC', conf['vWaveID'], 1)

    # wait for load kern args
    s_waitcnt(fp, 0, 'lgkm')
    write_line(fp)

    # global address of A/B
    global_address_assignment(conf, fp, 'A')
    global_address_assignment(conf, fp, 'B')

    do_fetch(conf, fp)
'''
    # prefetch 2 A/B iterations to lds
    s_barrier(fp)
    a_cnt = fetch2lds(conf, fp, 'A')    # A[0]
    b_cnt = fetch2lds(conf, fp, 'B')
    fetch2lds(conf, fp, 'A')    # A[1]
    fetch2lds(conf, fp, 'B')

    # wait for A[0]
    s_waitcnt(fp, 2 * b_cnt + a_cnt, 'vm')
    s_barrier(fp) 
    # wait for B[0]
    s_waitcnt(fp, b_cnt + a_cnt, 'vm')
    s_barrier(fp)
'''


def init_accvgpr(fp, i, tab=1):
    write_line(fp, 'v_accvgpr_write\t%s, 0, 0' % reg_str('vgprAcc', start_off=i), tab=tab)


def listify(d):
    if isinstance(d, list): return d
    if isinstance(d, tuple): return list(d)
    return [d]


def for_loop(loops, funcs, start=0, idxs='i,j,k,l,m,n'):
    loops, funcs = listify(loops), listify(funcs)
    idxs = idxs.split(',')
    tab = 1
    for i, k in enumerate(loops):
        idx = idxs[i]
        write_line(fp, 'for var %s = %d; %s < %d; %s++' % (idx, start, idx, k, idx), tab=tab)
        tab += 1
    for o in funcs: o(tab=tab+1)
    for i in range(len(loops)):
        tab -= 1
        if tab <= 0: break
        write_line(fp, 'end', tab=tab)
    write_line(fp)


def local_address_assignment(conf, fp, mat):
    write_comments(fp, 'local address of %s' % mat, tab=1)

    src = 'vgprLocalReadAddr' + mat
    src2 = 'vgprLocalReadAddr%s+1' % mat
    base = 'var%s_lds_base_addr' % mat
    step = 'varlds_%ssize_per_wg' % mat
    wave_sz = 'varlds_%ssize_per_wave' % mat
    k = conf['mfma']['k']

    # map thread to lds, map to 32 lanes
    v_mask(fp, 'v1', conf['vWFTID'], '0x1f') # mask 32
    v_mul(fp, src, 32, 'v1', dtype='u32')
    write_line(fp)

    # calc pad length
    v_lshr(fp, 'v2', 2, 'v1') # a pad follow by 4 wr
    v_mul(fp, 'v2', 'varlds_pad', 'v2', dtype='u32')
    write_line(fp)

    # 2 threads map to 1 lane, read k elements per lane
    v_lshr(fp, 'v1', 5, conf['vWFTID'])
    v_lshl(fp, 'v1', to_shift_bit(k / 2), 'v1')
    v_add(fp, src, 'v1', src, dtype='u32')
    cvt2bytes(fp, src)
    write_line(fp)

    # add pad
    v_add(fp, src, src, 'v2', dtype='u32')
    write_line(fp)

    # address subgrp of B, 1 wave of A can boardcast to all 4 waves of B
    if mat == 'B':
        s_mul(fp, 's84', 'sgprFetchSubGrpId', wave_sz)
        v_add(fp, src, 's84', src, dtype='u32')

    # add to base addr
    v_add(fp, src, base, src, dtype='u32')
    v_add(fp, src2, step, src, dtype='u32')
    write_line(fp)


def def_mac(conf, fp):
    write_line(fp, 'wave0_MAC:')
    write_line(fp)
    write_comments(fp, 'hide all memory  load (kern args load) latency with ACC VGPR initialization', tab=1)
    for_loop(32, partial(init_accvgpr, fp, 'i'))

    t2d_sizeC = load_karg(conf, fp, 'sgprTensor2dSizeC', 2)
    alpha = load_karg(conf, fp, 'sgprAlpha', 4)
    beta = alpha + '+1'
    strideD = load_karg(conf, fp, 'sgprStridesD', 4)
    strideC = strideD + '+2'
    addrD = load_karg(conf, fp, 'sgprAddressD', 4)
    addrC = addrD + '+2'
    write_line(fp)

    write_comments(fp, 'Local Read Addresses', bar=True, nl=True, tab=1)

    local_address_assignment(conf, fp, 'A')
    local_address_assignment(conf, fp, 'B')

    s_waitcnt(fp, 0, itype='lgkm')




if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.description = "Replacement kernel generator"
    parser.add_argument("-f", "--config", type=str, help='specify config file path')
    parser.add_argument("-o", "--output", type=str, help='specify output file path')
    args = parser.parse_args()

    if not args.config:
        print('No config file specified, please use "--help" for more details.')
        exit(-1)

    if not args.output:
        out_fpath = Path(args.config).stem + '.sp3'

    conf = json.load(open(args.config, 'r'))
    with open(out_fpath, 'w') as fp:
        def_regs(conf, fp)
        def_lds_vars(conf, fp)
        def_header(conf, fp)
        def_fetch(conf, fp)
        def_mac(conf, fp)
        def_foot(conf, fp)

    print("[Output]: %s" % out_fpath)

