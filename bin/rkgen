#!/usr/bin/env python3


import argparse
import json
import os
import pdb
#import numpy as np
#import pandas as pd
from pathlib import Path
from functools import partial


def def_vars(conf, wrt):
    # sgpr & vgpr variables
    for k in ['sregs', 'vregs']:
        wrt.comments('Define %s variables' % k)
        for k, v in conf[k].items():
            wrt.def_var(k, v)
        wrt.empty_line()

    wrt.def_var('BufferLimit', 0x80000000, cmt='2GB limit - set offsets to -1 to exceed this and clamp')
    wrt.def_var('Srd127_96', 0x20000, cmt='Bits 127:96 of SRD.  Set DataFormat = 32 bit')
    wrt.def_var('roundMaskVal', 0xffff0000, nl=True)

    # lds variables
    pad = 8
    mt_h = conf['mt']['h']
    mt_w = conf['mt']['w']
    simd = conf['mfma']['simd']
    a_per_wr = 256 + pad
    lvca = int(32 / (conf['glvw'] * 2))
    rows_per_wave = int(mt_h / simd)
    a_vw = int(rows_per_wave / (64 / lvca))
    a_per_wave = a_per_wr * a_vw
    a_per_wg = a_per_wave * simd
    b_per_wr = 256 + pad
    lvcb = int(32 / (conf['glvw'] * 2))
    cols_per_wave = int(mt_w / simd)
    b_vw = int(cols_per_wave / (64 / lvcb))
    b_per_wave = b_per_wr * b_vw
    b_per_wg = b_per_wave * simd

    wrt.comments("Define lds vars")
    wrt.def_var('varlds_pad', pad)
    wrt.def_var('varlds_Asize_per_wr', a_per_wr, cmt='256 + varlds_pad')
    wrt.def_var('varlds_Asize_per_wave', 'varlds_Asize_per_wr * %d' % a_vw, cmt='vw == %d' % a_vw)
    wrt.def_var('varlds_Asize_per_wg', 'varlds_Asize_per_wave * %d' % simd)
    wrt.empty_line()
    wrt.def_var('varlds_Bsize_per_wr', b_per_wr, cmt='256 + varlds_pad')
    wrt.def_var('varlds_Bsize_per_wave', 'varlds_Bsize_per_wr * %d' % b_vw, cmt='vw == %d' % b_vw)
    wrt.def_var('varlds_Bsize_per_wg', 'varlds_Bsize_per_wave * %d' % simd)
    wrt.empty_line()
    wrt.def_var('varA_lds_base_addr', 0)
    wrt.def_var('varB_lds_base_addr', 'varA_lds_base_addr + varlds_Asize_per_wg * 2')
    wrt.empty_line()

    conf['lvca'] = lvca
    conf['lvcb'] = lvcb
    conf['A_VW'] = a_vw
    conf['B_VW'] = b_vw
    conf['C_VW'] = (a_vw, b_vw)


def def_header(conf, wrt):
    wrt.write_line('shader main', tab=0)
    wrt.write_line('type(CS)')
    wrt.write_line('user_sgpr_count(14)')
    wrt.write_line('tgid_x_en(1)')
    wrt.write_line('tgid_y_en(1)')
    wrt.write_line('tgid_z_en(1)')
    wrt.write_line('tidig_comp_cnt(2)')
    wrt.empty_line()


def def_footer(conf, wrt):
    wrt.label('finish')
    wrt.waitcnt(0)
    wrt.end_pgm()
    wrt.empty_line()
    wrt.write_line('end', tab=0)
    wrt.empty_line()


def reg_str(s, start_off=0, end_off=0):
    if isinstance(s, str) and (s.startswith('v[') or s.startswith('s[')):
        return s
    if isinstance(s, int) or (isinstance(s, str) and s[0].isdigit()):
        return s
    if isinstance(s, tuple):
        s, *off = s
        start_off = off[0]
        if len(off) > 1: end_off = off[1]
    if not s.startswith('vgpr') and not s.startswith('sgpr'):
        return s
    dtype = 'v' if s.startswith('vgpr') else 's'
    if end_off != 0: 
        s = '%s+%s:%s+%s' % (s, start_off, s, end_off)
    elif start_off != 0:
        s = '%s+%s' % (s, start_off)
    return dtype + '[' + s + ']'


# load kernel args to sgpr
def load_karg(conf, wrt, var, dw=1):
    wrt.s_load(var, 'sgprKernArgAddress', conf['kargs'][var], dw=dw)


def var_str(*s):
    return '+'.join(str(o) for o in s)


def get_thread_info(conf, wrt):
    #vgprSerial    holds threadIdx
    #vgprSerial+1  holds WaveFrontId (0-63)
    #vgprSerial+2  holds threadIdy  (simd= 0,1,2,3)
    #vgprSerial+3  holds threadIdZ  (wave0 =0 wave1 = 1)
    tid = 'vgprSerial'
    wf_tid = var_str(tid, 1)
    simd_id = var_str(tid, 2)
    wave_id = var_str(tid, 3)

    wrt.v_mov(tid, 'v0')
    wrt.v_mask(wf_tid, tid, 64) # wave front id

    #HW_ID_REG
    #bit[0-3] #waveId
    #bit[5-4] #simdId
    #bit[11-8] #CuId
    hwid = 'sgprHWID'
    wrt.read_hwreg(hwid, 'HW_REG_HW_ID')
    wrt.v_mask('v4', '0x30', hwid)  # simd
    wrt.v_lshr(simd_id, 4, 'v4')
    wrt.v_mask(wave_id, '0xf', hwid) # waveid
    conf['vTID'] = tid
    conf['vWFTID'] = wf_tid
    conf['vSIMDID'] = simd_id
    conf['vWaveID'] = wave_id
    wrt.empty_line()


def create_branch(wrt, label, var, val, eq=False):
    svar = 'sgprHWID+1'
    wrt.vgpr2sgpr(svar, var)
    wrt.cmp_jmp(label, svar, val, eq=False)
    wrt.empty_line()


def to_shift_bit(val):
    b, s = 0, 1
    while s < val:
        s *= 2
        b += 1
    return b


def mat_idx(mat):
    if mat == 'A': return 0
    elif mat == 'B': return 1


class MatrixAB():
    def __init__(self, conf, wrt, mat):
        self.conf, self.wrt, self.mat = conf, wrt, mat
        self.global_read_dest_addr = 'vgprG2L' + mat
        self.global_read_src_addr = 'vgprGlobalReadOfvar' + mat
        self.global_read_offset = 'sgprScalarGlobalReadOffset' + mat
        self.local_write_addr = 'sgprLocalWriteAddr' + mat
        self.local_read_addr = 'vgprLocalReadAddr' + mat
        self.reg_addr = 'vgprValu%s_X0_I0' % mat
        self.src = 'sgprAddress' + mat
        self.src_desc = 'sgprSrd' + mat
        self.simd_id = 'sgprFetchSubGrpId'
        self.stride = ('sgprStrides' + mat, 'sgprStrides%s+1' % mat)
        self.vw = conf[mat + '_VW']
        self.wg = ('sgprWorkGroup0', 'sgprWorkGroup1', 'sgprWorkGroup2')
        self.sz_per_wr = 'varlds_%ssize_per_wr' % mat
        self.sz_per_wave = 'varlds_%ssize_per_wave' % mat
        self.sz_per_wg = 'varlds_%ssize_per_wg' % mat
        self.lds_base_addr = 'var%s_lds_base_addr' % mat
        self.vmcnt = 0

    def global_address(self):
        self.wrt.comments('Global Address Assignment for %s' % self.mat, bar=True, nl=True)

        self.wrt.comments('resource descriptor')
        self.wrt.s_mov(self.src_desc, self.src, cmt='sgpr[0-1] - base address')
        self.wrt.s_mov((self.src_desc, 1), (self.src, 1))
        self.wrt.s_mov((self.src_desc, 2), 'BufferLimit', cmt='sgpr[2]   - limit')
        self.wrt.s_mov((self.src_desc, 3), 'Srd127_96', cmt='sgpr[3]   - attributes')
        self.wrt.empty_line()

        # start address of workgroup
        wg_addr, wave_addr = 's84', 's85'
        mt = self.conf['mt']['h'] if self.mat == 'A' else self.conf['mt']['w']
        wg = self.wg[0] if self.mat == 'A' else self.wg[1]
        lines_per_wave = mt // 4
        lvca = self.conf['lvca']
        tid = self.conf['vWFTID']

        self.wrt.comments('%s: address of workgroup' % wg_addr)
        self.wrt.s_mul(wg_addr, self.stride[0], mt)
        self.wrt.s_mul(wg_addr, wg, wg_addr)

        self.wrt.comments('%s: address of wave' % wave_addr)
        self.wrt.s_mul(wave_addr, self.stride[0], lines_per_wave)
        self.wrt.s_mul(wave_addr, self.simd_id, wave_addr)
        self.wrt.s_add(wave_addr, wg_addr, wave_addr)

        lane_id, tile_addr, lane_addr = 'v0', 'v1', 'v4'

        self.wrt.comments('%s: address of lane' % lane_addr)
        self.wrt.comments('LVCA=%d' % lvca)
        self.wrt.v_lshr(lane_id, to_shift_bit(lvca), tid)
        self.wrt.v_mul(lane_addr, self.stride[0], lane_id, dtype='u32')

        self.wrt.comments('%s: address of tile' % tile_addr)
        self.wrt.v_mask(tile_addr, lvca - 1, tid)
        self.wrt.v_lshl(tile_addr, 1, tile_addr, cmt='1 dword == 2 elements')

        self.wrt.comments('%s: address of global address' % self.global_read_src_addr)
        self.wrt.v_add(self.global_read_src_addr, lane_addr, tile_addr, dtype='u32', carry_out=True)
        self.wrt.v_add(self.global_read_src_addr, self.global_read_src_addr, wave_addr, dtype='u32')
        self.wrt.cvt2byte(self.global_read_src_addr)

        self.wrt.empty_line()

        self.wrt.comments('%s: offset of vector width' % self.global_read_offset)
        self.wrt.comments('vw=-1')
        # 4 lanes * 2 bytes per element, next read from 5th lane
        self.wrt.s_lshl(self.global_read_offset, self.stride[0], 3) 
        self.wrt.s_sub(self.global_read_offset, self.global_read_offset, self.sz_per_wr, dtype='u32')
        for i in range(1, self.vw):
            self.wrt.v_add((self.global_read_src_addr, i), self.global_read_offset,
                    (self.global_read_src_addr, i - 1))
        self.wrt.empty_line()

        self.wrt.comments('set local write address')
        self.wrt.s_mov(self.local_write_addr, self.sz_per_wave)
        self.wrt.s_mul(self.local_write_addr, self.simd_id, self.local_write_addr)
        self.wrt.s_add(self.local_write_addr, self.local_write_addr, self.lds_base_addr)
        self.wrt.s_add((self.local_write_addr, 1), self.local_write_addr, self.sz_per_wave)
        self.lds_ptr = self.local_write_addr
        self.wrt.empty_line()

    def global_fetch(self):
        self.wrt.comments('fetch %s to lds' % self.mat)
        self.update_lds_ptr()
        for i in range(self.vw):
            offset = '%s * %d' % (self.sz_per_wr, i)
            self.wrt.buffer_load((self.global_read_dest_addr, i), (self.global_read_src_addr, i),
                    (self.src_desc, 0, 3), lds=1, offset=offset)
        self.vmcnt += self.vw
        self.wrt.empty_line()

    def update_lds_ptr(self):
        self.wrt.comments('set lds base address to %s' % self.lds_ptr)
        self.wrt.set_lds_addr(self.lds_ptr)
        self.lds_ptr = var_str(self.local_write_addr, 1) if self.lds_ptr == self.local_write_addr else self.local_write_addr

    def global_inc_fetch_addr(self, prio=0):
        self.wrt.comments('increment global address of %s to next iteration' % self.mat)
        # update to next iteration 
        if prio:
            self.wrt.setprio(prio)
        for i in range(self.vw):
            self.wrt.v_add((self.global_read_src_addr, i), 64, (self.global_read_src_addr, i))
        if prio:
            self.wrt.setprio(0)
        self.wrt.empty_line()

    def wait4fetch(self):
        self.wrt.waitcnt(20 if self.mat == 'A' else 12, 'vm')
        self.wrt.barrier(cmt='wait for LDS %s' % self.mat) 
        self.wrt.empty_line()

    def local_address(self):
        # all wave load the same A, 4 waves load 4 Bs
        # map threads to 32 lanes on LDS
        self.wrt.comments('Local Address Assignment for %s' % self.mat, bar=True, nl=True)
        self.wrt.comments('%s: address of lane' % self.local_read_addr)
        tid = 'v1'
        self.wrt.v_mask(tid, self.conf['vWFTID'], '0x1f') # tid_wavefront mask 32, 2 threads per lane
        self.wrt.v_mul(self.local_read_addr, 32, tid, dtype='u32') # map to column
        self.wrt.empty_line()

        # calc pad length
        pad_len, pad = 'v2', 'varlds_pad'
        self.wrt.comments('%s: padding length' % pad_len)
        self.wrt.v_lshr(pad_len, 2, tid) # a pad follow by 4 wr
        self.wrt.v_mul(pad_len, pad, pad_len, dtype='u32')
        self.wrt.empty_line()

        # 2 threads map to 1 lane, read threadtile elements per thread
        tid_lane = 'v1'
        self.wrt.comments('%s: address of threadtile' % self.local_read_addr)
        self.wrt.v_lshr(tid_lane, 5, conf['vWFTID'])
        self.wrt.v_lshl(tid_lane, to_shift_bit(conf['thread_tile']), tid_lane)
        self.wrt.v_add(self.local_read_addr, tid_lane, self.local_read_addr, dtype='u32')
        self.wrt.cvt2byte(self.local_read_addr)
        self.wrt.empty_line()

        # add pad
        self.wrt.comments('add padding length')
        self.wrt.v_add(self.local_read_addr, self.local_read_addr, pad_len, dtype='u32')
        self.wrt.empty_line()

        # address subgrp of B, 1 wave of A can boardcast to all 4 waves of B
        if self.mat == 'B':
            wave_addr = 's84'
            self.wrt.comments('4 waves load 4 B, %s: address of wave' % wave_addr)
            self.wrt.s_mul(wave_addr, self.simd_id, self.sz_per_wave)
            self.wrt.v_add(self.local_read_addr, wave_addr, self.local_read_addr, dtype='u32')
            self.wrt.empty_line()

        # add title offset to base addr
        self.wrt.v_add(self.local_read_addr, self.lds_base_addr, self.local_read_addr, dtype='u32')
        self.wrt.v_add((self.local_read_addr, 1), self.sz_per_wg, self.local_read_addr, dtype='u32')
        self.wrt.empty_line()


class MatrixCD():
    def __init__(self, conf, wrt, mat):
        self.conf, self.wrt, self.mat = conf, wrt, mat
        self.global_write_src_addr = 'vgprGlobalWriteOfvar' + mat
        self.src = 'sgprAddress' + mat
        self.src_desc = 'sgprSrd' + mat
        self.reg_addr = 'vgprValu%s' % mat
        self.simd_id = 'sgprFetchSubGrpId'
        self.stride = ('sgprStrides' + mat, 'sgprStrides%s+1' % mat)
        self.mt = (conf['mt']['h'], conf['mt']['w'])
        self.wg = ('sgprWorkGroup0', 'sgprWorkGroup1', 'sgprWorkGroup2')
        self.sz_per_wr = 'varlds_%ssize_per_wr' % mat
        self.sz_per_wave = 'varlds_%ssize_per_wave' % mat
        self.sz_per_wg = 'varlds_%ssize_per_wg' % mat
        self.vmcnt = 0

    def global_address(self):
        self.wrt.comments('Global Address Assignment for %s' % self.mat, bar=True, nl=True)

        self.wrt.comments('resource descriptor')
        self.wrt.s_mov(self.src_desc, self.src, cmt='sgpr[0-1] - base address')
        self.wrt.s_mov((self.src_desc, 1), (self.src, 1))
        self.wrt.s_mov((self.src_desc, 2), 'BufferLimit', cmt='sgpr[2]   - limit')
        self.wrt.s_mov((self.src_desc, 3), 'Srd127_96', cmt='sgpr[3]   - attributes')
        self.wrt.empty_line()

        # calc workgroup address on y dim
        wg_addr, wg_addr_hi, wg_addr_lo = 's[84:85]', 's85', 's84'
        self.wrt.comments('[%s:%s]: address of workgroup on y dim' % (wg_addr_hi, wg_addr_lo))
        self.wrt.s_mul(wg_addr_hi, self.mt[1], self.wg[1])
        self.wrt.s_mul(wg_addr_lo, wg_addr_hi, self.stride[0])
        self.wrt.s_mul(wg_addr_hi, wg_addr_hi, self.stride[0], hi=True, dtype='u32')
        self.wrt.s_lshl(wg_addr, wg_addr, 1, dtype='b64', cmt='scale by bpe')
        self.wrt.s_add(self.src_desc, self.src_desc, wg_addr_lo, dtype='u32')
        self.wrt.s_add((self.src_desc, 1), (self.src_desc, 1), wg_addr_hi, carry_out=True, dtype='u32')
        self.wrt.empty_line()

        # calc workgroup address on z dim
        self.wrt.comments('[%s:%s]: address of workgroup on z dim' % (wg_addr_hi, wg_addr_lo))
        self.wrt.s_mul(wg_addr_hi, self.wg[2], self.stride[1], hi=True, dtype='u32')
        self.wrt.s_mul(wg_addr_lo, self.wg[2], self.stride[1])
        self.wrt.s_lshl(wg_addr, wg_addr, 1, dtype='b64', cmt='scale by bpe')
        self.wrt.s_add(self.src_desc, self.src_desc, wg_addr_lo, dtype='u32')
        self.wrt.s_add((self.src_desc, 1), (self.src_desc, 1), wg_addr_hi, carry_out=True, dtype='u32')
        self.wrt.empty_line()

        # remap z dim to x dim
        # use z dim to re-map threadIdx using for calculating waveId start off set for MAC wves to store 'C'
        self.wrt.comments('use z dim to re-map threadIdx using for calculating waveId start off set for MAC wves to store C')
        self.wrt.v_lshl(conf['vTID'], 6, conf['vWaveID'], cmt='threadIdx = simdId<<6')
        self.wrt.v_add(conf['vTID'], conf['vWFTID'], conf['vTID'], dtype='u32', cmt='threadIdx = threadIdx + 0-63')
        self.wrt.v_mul('v4', 32, conf['vWFTID'], dtype='u32', cmt='scale by sub-tile-size 32 (B-tile/128)')
        self.wrt.v_mul('v3', 'v4', self.stride[0], dtype='u32', cmt='wavestart vgpr')
        self.wrt.v_mask('v4', '0x1f', conf['vTID'], cmt='vectorStaticDiv vgprTmp = vgprSerial % 31')
        self.wrt.v_mul('v5', 'v4', self.stride[0], dtype='u32', cmt='rowstart VGPR')
        self.wrt.v_mask('v4', '0x3f', conf['vTID'], cmt='vectorStaticDiv vgprTmp = vgprSerial % 63')
        self.wrt.v_lshr('v6', 5, 'v4', cmt='vectorStaticDiv vgprTmp = vgprSerial / 32')
        self.wrt.v_lshr('v6', 2, 'v6', cmt='*4')
        self.wrt.v_add('vgprTmp+1', 'v3', 'v5', dtype='u32')
        self.wrt.empty_line()

        # calc workgroup address on x dim 
        self.wrt.s_mul(wg_addr_lo, self.mt[0], self.wg[0])
        self.wrt.v_add('vgprTmp', wg_addr_lo, 'v6', carry_out=True, dtype='u32')
        self.wrt.v_add_lshl(self.global_write_src_addr, 'vgprTmp', 'vgprTmp+1', 1, cmt='base_addr = wave_start+row_start scaled by BPE')
        self.wrt.empty_line()


class MAC():
    def __init__(self, wrt, mat_a, mat_b, mat_c):
        self.wrt = wrt
        self.mat = {'A': mat_a, 'B': mat_b, 'C': mat_c}
        self.acc_idxs = {'A': 0, 'B': 0, 'C': [0, 0]}
        self.mfma_idxs = 0
        self.loadcnt = 0
        self.reg_addr = 'vgprAcc'

    def loadAB(self, mat='A', cnt=1):
        m = self.mat[mat]
        off = '%s * 2' % m.sz_per_wave
        for i in range(cnt):
            acc = i + self.acc_idxs[mat]
            blk = self.acc_idxs[mat] // 4
            k = (acc // 4 * 16) if mat == 'A' else (acc // 4 * 8)
            j =  k + (acc % 4) * 2
            i = acc % 4
            if mat == 'A':
                self.wrt.ds_read((m.reg_addr, j, j + 1), (m.local_read_addr, blk), i * 16) # A[0]
                self.wrt.ds_read((m.reg_addr, 8 + j, 8 + j + 1), (m.local_read_addr, blk),
                        '%s + %d' % (off, (i % 4) * 16)) # A[1]
            else:
                self.wrt.ds_read((m.reg_addr, j, j + 1), (m.local_read_addr, blk), i * 16) # B
            self.loadcnt += 1
        self.acc_idxs[mat] = (self.acc_idxs[mat] + cnt) % 8

    def mfma(self, cb=None):
        mat_a, mat_b = self.mat['A'], self.mat['B']
        i = (self.mfma_idxs // 4 * 16) + (self.mfma_idxs % 4) * 2
        j = (self.mfma_idxs // 4 * 8) + (self.mfma_idxs % 4) * 2
        self.wrt.v_mfma(self.reg_addr, (mat_a.reg_addr, i), (mat_b.reg_addr, j), self.reg_addr)
        if cb: cb()
        self.wrt.v_mfma((self.reg_addr, 16), (mat_a.reg_addr, 8 + i), (mat_b.reg_addr, j), (self.reg_addr, 16))
        self.mfma_idxs = (self.mfma_idxs + 1) % 8

    def getC(self, cnt):
        m = self.mat['C']
        acc = self.acc_idxs['C'][0]
        start = acc % 16
        end = start + cnt
        k = (acc // 16) * 16
        acc2reg = partial(self.wrt.v_accvgpr, (m.reg_addr, 'i'), (self.reg_addr, 'i+%d' % k), 0)
        self.wrt.for_loop(end, acc2reg, start=start)
        self.acc_idxs['C'][0] = min(self.acc_idxs['C'][0] + cnt, 16)

    def storeC(self, cnt):
        m = self.mat['C']
        acc = self.acc_idxs['C'][1]

        for i in [o * 2 for o in range(cnt)]:
            i += acc
            k = (i // 8) * 64
            i = i % 8
            j = i * 2
            self.wrt.fp16((m.reg_addr, j))
            self.wrt.fp16((m.reg_addr, j + 1))
            self.wrt.v_lshl_or((m.reg_addr, i), (m.reg_addr, j + 1), 16, (m.reg_addr, j))
            self.wrt.v_pk_mul((m.reg_addr, i), 'sgprAlpha', (m.reg_addr, i))
            self.wrt.fp16((m.reg_addr, j + 2))
            self.wrt.fp16((m.reg_addr, j + 3))
            self.wrt.v_lshl_or((m.reg_addr, i + 1), (m.reg_addr, j + 3), 16, (m.reg_addr, j + 2))
            self.wrt.v_pk_mul((m.reg_addr, i + 1), 'sgprAlpha', (m.reg_addr, i + 1))
            self.wrt.buffer_store((m.reg_addr, i, i + 1), m.global_write_src_addr,
                    m.src_desc, offset=(k + (i % 8) * 8))
            self.wrt.empty_line()
        self.acc_idxs['C'][1] = (acc + cnt * 2) % 16


def unroll_matmul(wrt, mac):
    # unroll 0
    wrt.barrier(cmt='A[0] is ready', nl=True)

    mac.loadAB('A', 4)
    wrt.barrier(cmt='B[0] is ready', nl=True)

    mac.loadAB('B', 2)
    wrt.setprio(1)
    wrt.empty_line()

    wrt.waitcnt(1, 'lgkm')
    mac.mfma(partial(mac.loadAB, 'B', 2)) # mfma instr 1
    wrt.waitcnt(2, 'lgkm')
    mac.mfma() # mfma instr 2
    wrt.waitcnt(0, 'lgkm')
    mac.mfma() # mfma instr 3
    wrt.setprio(0)
    wrt.barrier(cmt='A[1] is ready', nl=True)

    # unroll 1
    mac.loadAB('A', 2)
    mac.mfma(partial(mac.loadAB, 'A', 2)) # mfma instr 4
    wrt.empty_line()

    wrt.barrier(cmt='B[1] is ready', nl=True)

    mac.loadAB('B', 2)
    wrt.setprio(1)
    mac.mfma(partial(mac.loadAB, 'B', 2)) # mfma instr 5
    wrt.empty_line()

    mac.mfma() # mfma instr 6
    mac.mfma() # mfma instr 7
    wrt.setprio(0)
    mac.mfma() # mfma instr 8
    
    wrt.empty_line()


def do_mac(conf, wrt, mat_a, mat_b, mat_c):
    wrt.comments('MAC with mfma instruction', bar=True, nl=True)

    # mfma k == 8, 2 threads per lane, 1 thread read 4 elements
    # wait for LDS ready

    mac = MAC(wrt, mat_a, mat_b, mat_c)

    wrt.while_loop('MAC_loop', partial(unroll_matmul, wrt, mac), end=-2, step=2)
    wrt.empty_line()

    mac.getC(16)
    mac.storeC(4)
    mac.getC(16)
    mac.storeC(2)
    mac.storeC(2)


def unroll_fetch(wrt, mat_a, mat_b):
    wrt.barrier(cmt='wait for LDS A[0] & B[0]')
    wrt.empty_line()

    wrt.comments('unroll 0')
    mat_a.global_fetch()
    mat_b.global_fetch()
    mat_a.wait4fetch()
    mat_a.global_inc_fetch_addr(prio=1)
    mat_b.wait4fetch()
    mat_b.global_inc_fetch_addr(prio=1)

    wrt.barrier(cmt='wait for LDS A[1] & B[1]')
    wrt.empty_line()

    wrt.comments('unroll 1')
    mat_a.global_fetch()
    mat_b.global_fetch()
    mat_a.wait4fetch()
    mat_a.global_inc_fetch_addr(prio=1)
    mat_b.wait4fetch()
    mat_b.global_inc_fetch_addr(prio=1)
    wrt.empty_line()


def def_fetch(conf, wrt, mat_a, mat_b):
    # load A/B address, stridesA/B, sgprTensor2dSizeA/B, size L
    load_karg(conf, wrt, 'sgprAddressA', 4)
    load_karg(conf, wrt, 'sgprStridesA', 4)
    load_karg(conf, wrt, 'sgprTensor2dSizeA', 4)
    load_karg(conf, wrt, 'sgprSizesSum')
    wrt.empty_line()

    # clamp lds size to 0x3000
    wrt.set_lds_addr(0x3000)

    get_thread_info(conf, wrt)

    create_branch(wrt, 'wave0_MAC', conf['vWaveID'], 1)

    # wait for load kern args
    wrt.waitcnt(0, 'lgkm')
    wrt.empty_line()

    mat_a.global_address()
    mat_b.global_address()

    wrt.comments('Global Fetch A & B', bar=True, nl=True)
    wrt.barrier(cmt='sync up for global fetch')
    wrt.empty_line()

    # A[0], B[0]
    mat_a.global_fetch()
    mat_b.global_fetch()
    mat_a.global_inc_fetch_addr()
    mat_b.global_inc_fetch_addr()

    # A[1], B[1]
    mat_a.global_fetch()
    mat_b.global_fetch()
    mat_a.global_inc_fetch_addr()
    mat_b.global_inc_fetch_addr()

    mat_a.wait4fetch()
    mat_b.wait4fetch()

    wrt.while_loop('fetch_loop', partial(unroll_fetch, wrt, mat_a, mat_b), end=-2, step=2)

    # finish fetch
    wrt.waitcnt(8, 'vm')
    wrt.barrier()
    wrt.waitcnt(0, 'vm')
    wrt.barrier()
    wrt.empty_line()
    wrt.end_pgm()
    wrt.empty_line()
    wrt.empty_line()


def listify(d):
    if isinstance(d, list): return d
    if isinstance(d, tuple): return list(d)
    return [d]


def def_mac(conf, wrt, mat_a, mat_b, mat_c):
    wrt.label('wave0_MAC')
    wrt.comments('hide all kern args load latency with ACC VGPR initialization')
    wrt.for_loop(32, partial(wrt.v_accvgpr, ('vgprAcc', 'i'), 0, 0, op='write'))

    load_karg(conf, wrt, 'sgprTensor2dSizeC', 2)
    load_karg(conf, wrt, 'sgprAlpha', 4)
    load_karg(conf, wrt, 'sgprStridesD', 4)
    load_karg(conf, wrt, 'sgprAddressD', 4)
    wrt.empty_line()

    mat_a.local_address()
    mat_b.local_address()

    # wait for kern vars load
    wrt.waitcnt(0, op='lgkm', nl=True, cmt='wait for kern variables ready')

    # calc Matrix C global write address
    mat_c.global_address()

    do_mac(conf, wrt, mat_a, mat_b, mat_c)


class GFX9Writer():
    def __init__(self, fp):
        self.fp = fp

    def write_line(self, s='', cmt='', tab=1, nl=False):
        pre_s = '  ' * tab
        if cmt != '':
            if not cmt.startswith('//'):
                cmt = '// ' + cmt
            cmt = '\t\t' + cmt
        self.fp.write(pre_s + s + cmt + '\n')
        if nl:
            self.fp.write('\n')

    def comments(self, s, bar=False, bar_len=40, tab=1, nl=False):
        pre_s = '  ' * tab
        if bar:
            bar_s = pre_s + '/' + '*' * bar_len + '/\n'
        s = pre_s + '/* ' + s + ' */\n' if bar else pre_s + '// ' + s + '\n'
        if bar:
            self.fp.write(bar_s)
        fp.write(s)
        if bar:
            self.fp.write(bar_s)
        if nl:
            self.fp.write('\n')

    def empty_line(self):
        self.fp.write('\n')

    def def_var(self, name, val, **kwargs):
        self.write_line('var ' + name + ' = ' + str(val), tab=0, **kwargs)

    def barrier(self, **kwargs):
        self.write_line('s_barrier', tab=1, **kwargs)

    def setprio(self, prio, nl=False):
        self.write_line('s_setprio %d' % prio, tab=1, nl=nl)

    def waitcnt(self, cnt, op=None, **kwargs):
        s = '%scnt(%d)' % (op, cnt) if op else str(cnt)
        self.write_line('s_waitcnt\t%s' % s, **kwargs)

    def sopc_instr(self, src0, src1, op, dtype, **kwargs):
        src0, src1 = reg_str(src0), reg_str(src1)
        self.write_line('s_cmp_%s_%s\t%s, %s' % (op, dtype, src0, src1), **kwargs)

    def sop1_sopk_instr(self, cmd, dtype, dest, src, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('s_%s_%s\t%s, %s' % (cmd, dtype, dest, src), **kwargs)

    def sop2_instr(self, cmd, dtype, dest, src0, src1, **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('s_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
            src1), **kwargs)

    def s_mov(self, dest, src, dtype='b32', **kwargs):
        self.sop1_sopk_instr('mov', dtype, dest, src, **kwargs)

    def s_sub(self, dest, src0, src1, dtype='i32', **kwargs):
        self.sop2_instr('sub', dtype, dest, src0, src1, **kwargs)

    def s_mul(self, dest, src0, src1, hi=False, dtype='i32', **kwargs):
        self.sop2_instr('mul_hi' if hi else 'mul', dtype, dest, src0, src1, **kwargs)

    def s_lsh(self, dest, src0, src1, ldir=True, dtype='b32', **kwargs):
        self.sop2_instr('lshl' if ldir else 'lshr', dtype, dest, src0, src1, **kwargs)

    def s_lshl(self, dest, src0, src1, dtype='b32', **kwargs):
        self.s_lsh(dest, src0, src1, dtype=dtype, ldir=True, **kwargs)

    def s_lshr(self, dest, src0, src1, dtype='b32', **kwargs):
        self.s_lsh(dest, src0, src1, dtype=dtype, ldir=False, **kwargs)

    def s_add(self, dest, src0, src1, carry_out=False, dtype='i32', **kwargs):
        self.sop2_instr('addc' if carry_out else 'add', dtype, dest, src0, src1, **kwargs)

    def s_cmp(self, src0, src1, op='eq', dtype='u32', **kwargs):
        src0, src1 = reg_str(src0), reg_str(src1)
        self.sopc_instr(src0, src1, op, dtype, **kwargs)

    def s_cbranch(self, label, eq=True, **kwargs):
        self.write_line('s_cbranch_scc%d\t%s' % (1 if eq else 0, label), **kwargs)

    def s_load(self, sgpr, src, off, dw=1, **kwargs):
        s = 's_load_dword%s %s, %s, 0x%x' % ('x' + str(dw) if dw > 1 else '',
                reg_str(sgpr, end_off=(dw - 1)),
                reg_str(src, end_off=1), off)
        self.write_line(s, **kwargs)

    def vop1_instr(self, cmd, dtype, dest, src, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('v_%s_%s\t%s, %s' % (cmd, dtype, dest, src), **kwargs)

    def vop2_instr(self, cmd, dtype, dest, src0, src1, **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('v_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
            src1), **kwargs)

    def vop3_instr(self, cmd, dtype, dest, src0, src1, src2, **kwargs):
        dest, src0, src1, src2 = reg_str(dest), reg_str(src0), reg_str(src1), reg_str(src2)
        self.write_line('v_%s_%s\t%s, %s, %s, %s' % (cmd, dtype, dest, src0,
            src1, src2), **kwargs)

    def v_lsh(self, dest, src0, src1, dtype, ldir, **kwargs):
        self.vop2_instr('lshlrev' if ldir else 'lshrrev', dtype, dest, src0, src1, **kwargs)

    def v_mask(self, dest, src, subgrp_sz, dtype='b32', **kwargs):
        self.vop2_instr('and', dtype, dest, src, subgrp_sz, **kwargs)

    def v_lshl(self, dest, src0, src1, dtype='b32', **kwargs):
        self.v_lsh(dest, src0, src1, dtype=dtype, ldir=True, **kwargs)

    def v_lshr(self, dest, src0, src1, dtype='b32', **kwargs):
        self.v_lsh(dest, src0, src1, dtype=dtype, ldir=False, **kwargs)

    def v_lsh_or(self, dest, src0, src1, src2, dtype, ldir, **kwargs):
        self.vop3_instr('lshl_or' if ldir else 'lshr_or', dtype, dest, src0, src1, src2, **kwargs)

    def v_lshl_or(self, dest, src0, src1, src2, dtype='b32', **kwargs):
        self.v_lsh_or(dest, src0, src1, src2, dtype=dtype, ldir=True, **kwargs)

    def v_lshr_or(self, dest, src0, src1, src2, dtype='b32', **kwargs):
        self.v_lsh_or(dest, src0, src1, src2, dtype=dtype, ldir=False, **kwargs)

    def v_mov(self, dest, src, dtype='b32', **kwargs):
        self.vop1_instr('mov', dtype, dest, src, **kwargs)

    def v_add(self, dest, src0, src1, carry_out=False, dtype='i32', **kwargs):
        if carry_out == False:
            self.vop2_instr('add', dtype, dest, src0, src1, **kwargs)
        else:
            dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
            self.write_line('v_add_co_%s\t%s, vcc, %s, %s' % (dtype, dest, src0,
                src1), **kwargs)

    def v_mul(self, dest, src0, src1, dtype='i32', **kwargs):
        self.vop2_instr('mul_lo', dtype, dest, src0, src1, **kwargs)

    def v_add_lshl(self, dest, src0, src1, src2, dtype='u32', **kwargs):
        self.vop3_instr('add_lshl', dtype, dest, src0, src1, src2)

    def v_pk_mul(self, dest, src0, src1, dtype='f16', **kwargs):
        self.vop2_instr('pk_mul', dtype, dest, src0, src1, **kwargs)

    def set_lds_addr(self, addr, **kwargs):
        self.s_mov('m0', addr, tab=1, nl=True, **kwargs)

    def read_hwreg(self, dest, src, **kwargs):
        self.sop1_sopk_instr('getreg', 'b32', dest, 'hwreg(' + src + ')', **kwargs)

    def vgpr2sgpr(self, dest, src, **kwargs):
        self.vop1_instr('readfirstlane', 'b32', dest, src, **kwargs)

    def label(self, s, **kwargs):
        self.write_line(s + ":", tab=0, **kwargs)

    def buffer_load(self, dest, off, src_desc, dw=1, lds=0, offset=None, **kwargs):
        dest, off, src_desc = reg_str(dest), reg_str(off), reg_str(src_desc, end_off=3)
        s = 'buffer_load_dword%s %s, %s, %s, %s' % ('x' + str(dw) if dw > 1 else '',
                dest, off, src_desc, '0 offen:1 lds:%d offset:%s' % (lds, offset))
        self.write_line(s, **kwargs)

    def buffer_store(self, dest, off, src_desc, dw=2, offset=None, **kwargs):
        dest, off, src_desc = reg_str(dest), reg_str(off), reg_str(src_desc, end_off=3)
        s = 'buffer_store_dword%s %s, %s, %s, %s' % ('x%d' % dw if dw > 1 else '',
                dest, off, src_desc, '0 offen:1 offset:%s' % offset)
        self.write_line(s, **kwargs)

    def cmp_jmp(self, label, var, val, eq=True, **kwargs):
        self.s_cmp(var, val, **kwargs)
        self.s_cbranch(label, eq, **kwargs)

    def end_pgm(self, **kwargs):
        self.write_line('s_endpgm', **kwargs)

    def cvt2byte(self, var, **kwargs):
        self.v_lshl(var, 1, var, **kwargs)

    def for_loop(self, end, func_list, start=0, step=1, idxs='i,j,k,l,m,n', tab=1, nl=True):
        end, func_list = listify(end), listify(func_list)
        idxs = idxs.split(',')
        for i, k in enumerate(end):
            idx = idxs[i]
            self.write_line('for var %s = %d; %s < %d; %s += %d' % (idx, start, idx,
                k, idx, step), tab=tab)
            tab += 1
        for o in func_list: o(tab=tab+1)
        for i in range(len(end)):
            tab -= 1
            if tab <= 0: break
            self.write_line('end', tab=tab)
        if nl: self.empty_line()

    def v_accvgpr(self, dest, src0, src1, op='read', **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('v_accvgpr_%s\t%s, %s, %s' % (op, dest, src0, src1), **kwargs)

    def ds_read(self, dest, src, off, dtype='b64', **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('ds_read_%s\t%s, %s offset:%s' % (dtype, dest, src, off), **kwargs)

    def v_mfma(self, dest, src0, src1, src2, dtype='f32_32x32x8f16', **kwargs):
        dest, src0, src1, src2 = reg_str(dest), reg_str(src0), reg_str(src1), reg_str(src2)
        self.write_line('v_mfma_%s\t%s, %s, %s, %s' % (dtype, dest, src0, src1, src2), **kwargs)

    def while_loop(self, label_name, cb, cnt='sgprLoopCounters', total_sz='sgprSizesSum', k=32, end=0, step=1):
        self.s_lshr(cnt, total_sz, to_shift_bit(k))
        self.s_sub(cnt, 0, cnt, nl=True)
        self.label(label_name)
        cb()
        self.s_add(cnt, step, cnt, dtype='u32')
        self.s_cmp(cnt, end, dtype='i32')
        self.s_cbranch(label_name, eq=False)
        self.empty_line()

    def fp16(self, var, dtype='f32', **kwargs):
        self.vop1_instr('cvt_f16', dtype, var, var, **kwargs)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.description = "Replacement kernel generator"
    parser.add_argument("-f", "--config", type=str, help='specify config file path')
    parser.add_argument("-o", "--output", type=str, help='specify output file path')
    args = parser.parse_args()

    if not args.config:
        print('No config file specified, please use "--help" for more details.')
        exit(-1)

    if not args.output:
        out_fpath = Path(args.config).stem + '.sp3'

    conf = json.load(open(args.config, 'r'))
    with open(out_fpath, 'w') as fp:
        writer = GFX9Writer(fp)
        def_vars(conf, writer)
        mat_a = MatrixAB(conf, writer, 'A')
        mat_b = MatrixAB(conf, writer, 'B')
        mat_c = MatrixCD(conf, writer, 'C')
        def_header(conf, writer)
        def_fetch(conf, writer, mat_a, mat_b)
        def_mac(conf, writer, mat_a, mat_b, mat_c)
        def_footer(conf, writer)

    print("[Output]: %s" % out_fpath)

