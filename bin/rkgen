#!/usr/bin/env python3
import argparse
import json
import os
import copy
import pdb
from pathlib import Path
from functools import partial
import collections


def dtype_size(dtype:str):
    elem_per_dword, elem_len = 1, 4
    if dtype == 'fp16' or dtype == 'bf16': elem_per_dword, elem_len = 2, 2
    return elem_per_dword, elem_len


def dw_str(dw:int):
    return 'b64' if dw == 2 else 'b32'


def reg_str(s, start_off=0, end_off=0):
    if isinstance(s, str) and (s.startswith('v[') or s.startswith('s[')):
        return s
    if isinstance(s, int) or (isinstance(s, str) and s[0].isdigit()):
        return s
    if isinstance(s, tuple):
        s, *off = s
        start_off = off[0]
        if len(off) > 1: end_off = off[1]
    if not s.startswith('vgpr') and not s.startswith('sgpr'):
        return s
    dtype = 'v' if s.startswith('vgpr') else 's'
    if end_off != 0: 
        s = '%s+%s:%s+%s' % (s, start_off, s, end_off)
    elif start_off != 0:
        s = '%s+%s' % (s, start_off)
    return dtype + '[' + s + ']'


def calc_mfma_blocks(block, subgrp):
    return max(block, subgrp) // min(block, subgrp)


def to_shift_bit(val):
    b, s = 0, 1
    while s < val:
        s *= 2
        b += 1
    return b


def listify(d):
    if isinstance(d, list): return d
    if isinstance(d, tuple): return list(d)
    return [d]


def get_mfma_info(s:str):
    d_regs_len, a_regs_len, b_regs_len = 16, 2, 2
    if s == '32x32x8f16':
        d_regs_len, a_regs_len, b_regs_len = 16, 2, 2
    elif s == '32x32x4bf16':
        d_regs_len, a_regs_len, b_regs_len = 16, 1, 1
    return (d_regs_len, d_regs_len, a_regs_len, b_regs_len)


class Sp3Writer():
    def __init__(self, fp):
        self.fp = fp

    def write_line(self, s='', cmt='', tab=1, nl=False):
        pre_s = '  ' * tab
        if cmt != '':
            if not cmt.startswith('//'):
                cmt = '// ' + cmt
            cmt = '\t\t' + cmt
        self.fp.write(pre_s + s + cmt + '\n')
        if nl:
            self.fp.write('\n')

    def comments(self, s, bar=False, bar_len=40, tab=1, nl=False):
        pre_s = '  ' * tab
        if bar:
            bar_s = pre_s + '/' + '*' * bar_len + '/\n'
        s = pre_s + '/* ' + s + ' */\n' if bar else pre_s + '// ' + s + '\n'
        if bar:
            self.fp.write(bar_s)
        self.fp.write(s)
        if bar:
            self.fp.write(bar_s)
        if nl:
            self.fp.write('\n')

    def empty_line(self):
        self.fp.write('\n')

    def def_var(self, name, val, **kwargs):
        self.write_line('var ' + name + ' = ' + str(val), tab=0, **kwargs)

    def barrier(self, **kwargs):
        self.write_line('s_barrier', tab=1, **kwargs)

    def setprio(self, prio, nl=False):
        self.write_line('s_setprio %d' % prio, tab=1, nl=nl)

    def waitcnt(self, cnt, op=None, **kwargs):
        s = '%scnt(%d)' % (op, cnt) if op else str(cnt)
        self.write_line('s_waitcnt\t%s' % s, **kwargs)

    def sopc_instr(self, src0, src1, op, dtype, **kwargs):
        src0, src1 = reg_str(src0), reg_str(src1)
        self.write_line('s_cmp_%s_%s\t%s, %s' % (op, dtype, src0, src1), **kwargs)

    def sop1_sopk_instr(self, cmd, dtype, dest, src, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('s_%s_%s\t%s, %s' % (cmd, dtype, dest, src), **kwargs)

    def sop2_instr(self, cmd, dtype, dest, src0, src1, **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('s_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
            src1), **kwargs)

    def s_mov(self, dest, src, dtype='b32', **kwargs):
        self.sop1_sopk_instr('mov', dtype, dest, src, **kwargs)

    def s_sub(self, dest, src0, src1, dtype='i32', **kwargs):
        self.sop2_instr('sub', dtype, dest, src0, src1, **kwargs)

    def s_mul(self, dest, src0, src1, hi=False, dtype='i32', **kwargs):
        self.sop2_instr('mul_hi' if hi else 'mul', dtype, dest, src0, src1, **kwargs)

    def s_lsh(self, dest, src0, src1, ldir=True, dtype='b32', **kwargs):
        self.sop2_instr('lshl' if ldir else 'lshr', dtype, dest, src0, src1, **kwargs)

    def s_lshl(self, dest, src0, src1, dtype='b32', **kwargs):
        self.s_lsh(dest, src0, src1, dtype=dtype, ldir=True, **kwargs)

    def s_lshr(self, dest, src0, src1, dtype='b32', **kwargs):
        self.s_lsh(dest, src0, src1, dtype=dtype, ldir=False, **kwargs)

    def s_add(self, dest, src0, src1, carry_out=False, dtype='i32', **kwargs):
        self.sop2_instr('addc' if carry_out else 'add', dtype, dest, src0, src1, **kwargs)

    def s_cmp(self, src0, src1, op='eq', dtype='u32', **kwargs):
        src0, src1 = reg_str(src0), reg_str(src1)
        self.sopc_instr(src0, src1, op, dtype, **kwargs)

    def s_cbranch(self, label, eq=True, **kwargs):
        self.write_line('s_cbranch_scc%d\t%s' % (1 if eq else 0, label), **kwargs)

    def s_load(self, sgpr, src, off, dw=1, **kwargs):
        s = 's_load_dword%s %s, %s, 0x%x' % ('x' + str(dw) if dw > 1 else '',
                reg_str(sgpr), reg_str(src), off)
        self.write_line(s, **kwargs)

    def vop1_instr(self, cmd, dtype, dest, src, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('v_%s_%s\t%s, %s' % (cmd, dtype, dest, src), **kwargs)

    def vop2_instr(self, cmd, dtype, dest, src0, src1, **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('v_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
            src1), **kwargs)

    def vop3_instr(self, cmd, dtype, dest, src0, src1, src2, **kwargs):
        dest, src0, src1, src2 = reg_str(dest), reg_str(src0), reg_str(src1), reg_str(src2)
        self.write_line('v_%s_%s\t%s, %s, %s, %s' % (cmd, dtype, dest, src0,
            src1, src2), **kwargs)

    def v_lsh(self, dest, src0, src1, dtype, ldir, **kwargs):
        self.vop2_instr('lshlrev' if ldir else 'lshrrev', dtype, dest, src0, src1, **kwargs)

    def v_mask(self, dest, src, subgrp_sz, dtype='b32', **kwargs):
        self.vop2_instr('and', dtype, dest, src, subgrp_sz, **kwargs)

    def v_lshl(self, dest, src0, src1, dtype='b32', **kwargs):
        self.v_lsh(dest, src0, src1, dtype=dtype, ldir=True, **kwargs)

    def v_lshr(self, dest, src0, src1, dtype='b32', **kwargs):
        self.v_lsh(dest, src0, src1, dtype=dtype, ldir=False, **kwargs)

    def v_lsh_or(self, dest, src0, src1, src2, dtype, ldir, **kwargs):
        self.vop3_instr('lshl_or' if ldir else 'lshr_or', dtype, dest, src0, src1, src2, **kwargs)

    def v_lshl_or(self, dest, src0, src1, src2, dtype='b32', **kwargs):
        self.v_lsh_or(dest, src0, src1, src2, dtype=dtype, ldir=True, **kwargs)

    def v_lshr_or(self, dest, src0, src1, src2, dtype='b32', **kwargs):
        self.v_lsh_or(dest, src0, src1, src2, dtype=dtype, ldir=False, **kwargs)

    def v_and_or(self, dest, src0, src1, src2, dtype='b32', **kwargs):
        self.vop3_instr('and_or', dtype, dest, src0, src1, src2, **kwargs)

    def v_mov(self, dest, src, dtype='b32', **kwargs):
        self.vop1_instr('mov', dtype, dest, src, **kwargs)

    def v_add(self, dest, src0, src1, carry_out=False, dtype='i32', **kwargs):
        if carry_out == False:
            self.vop2_instr('add', dtype, dest, src0, src1, **kwargs)
        else:
            dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
            self.write_line('v_add_co_%s\t%s, vcc, %s, %s' % (dtype, dest, src0,
                src1), **kwargs)

    def v_mul(self, dest, src0, src1, dtype='i32', **kwargs):
        self.vop2_instr('mul_lo', dtype, dest, src0, src1, **kwargs)

    def v_add_lshl(self, dest, src0, src1, src2, dtype='u32', **kwargs):
        self.vop3_instr('add_lshl', dtype, dest, src0, src1, src2)

    def v_pk_mul(self, dest, src0, src1, dtype='f16', **kwargs):
        self.vop2_instr('pk_mul', dtype, dest, src0, src1, **kwargs)

    def set_lds_addr(self, addr, **kwargs):
        self.s_mov('m0', addr, tab=1, **kwargs)

    def read_hwreg(self, dest, src, **kwargs):
        self.sop1_sopk_instr('getreg', 'b32', dest, 'hwreg(' + src + ')', **kwargs)

    def vgpr2sgpr(self, dest, src, **kwargs):
        self.vop1_instr('readfirstlane', 'b32', dest, src, **kwargs)

    def create_label(self, s, **kwargs):
        self.write_line(s + ":", tab=0, **kwargs)

    def buffer_load(self, dest, off, src_desc, dw=1, lds=0, offset=None, **kwargs):
        dest, off, src_desc = reg_str(dest), reg_str(off), reg_str(src_desc, end_off=3)
        s = 'buffer_load_dword%s %s, %s, %s, %s' % ('x' + str(dw) if dw > 1 else '',
                dest, off, src_desc, '0 offen:1 lds:%d offset:%s' % (lds, offset))
        self.write_line(s, **kwargs)

    def buffer_store(self, dest, off, src_desc, dw, offset=None, **kwargs):
        dest, off, src_desc = reg_str(dest), reg_str(off), reg_str(src_desc, end_off=3)
        s = 'buffer_store_dword%s %s, %s, %s, %s' % ('x%d' % dw if dw > 1 else '',
                dest, off, src_desc, '0 offen:1 offset:%s' % offset)
        self.write_line(s, **kwargs)

    def cmp_jmp(self, label, var, val, eq=True, **kwargs):
        self.s_cmp(var, val, **kwargs)
        self.s_cbranch(label, eq, **kwargs)

    def end_pgm(self, **kwargs):
        self.write_line('s_endpgm', **kwargs)

    def cvt2byte(self, var, **kwargs):
        self.v_lshl(var, 1, var, **kwargs)

    def for_loop(self, end, func_list, start=0, step=1, idxs='i,j,k,l,m,n', tab=1, nl=True):
        end, func_list = listify(end), listify(func_list)
        idxs = idxs.split(',')
        for i, k in enumerate(end):
            idx = idxs[i]
            self.write_line('for var %s = %d; %s < %d; %s += %d' % (idx, start, idx,
                k, idx, step), tab=tab)
            tab += 1
        for o in func_list: o(tab=tab+1)
        for i in range(len(end)):
            tab -= 1
            if tab <= 0: break
            self.write_line('end', tab=tab)
        if nl: self.empty_line()

    def v_accvgpr(self, dest, src0, src1, op='read', **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('v_accvgpr_%s\t%s, %s, %s' % (op, dest, src0, src1), **kwargs)

    def ds_read(self, dest, src, off, dtype, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('ds_read_%s\t%s, %s offset:%s' % (dtype, dest, src, off), **kwargs)

    def v_mfma(self, dest, src0, src1, src2, dtype='f32_32x32x8f16', **kwargs):
        dest, src0, src1, src2 = reg_str(dest), reg_str(src0), reg_str(src1), reg_str(src2)
        self.write_line('v_mfma_%s\t%s, %s, %s, %s' % (dtype, dest, src0, src1, src2), **kwargs)

    def unroll_loop(self, label_name, cb, cnt='sgprLoopCounters', total_sz='sgprSizesSum', k=32, end=0, step=1):
        self.s_lshr(cnt, total_sz, to_shift_bit(k))
        self.s_sub(cnt, 0, cnt, nl=True)
        self.create_label(label_name)
        cb()
        self.s_add(cnt, step, cnt, dtype='u32')
        self.s_cmp(cnt, end, dtype='i32')
        self.s_cbranch(label_name, eq=False)
        self.empty_line()

    def fp16(self, var, dtype='f32', **kwargs):
        self.vop1_instr('cvt_f16', dtype, var, var, **kwargs)


class KernGenerator(Sp3Writer):
    def __init__(self, conf:dict, fp):
        super().__init__(fp)
        for k, v in conf.items():
            setattr(self, k, v)
        self.conf = conf
        self.init_vars()

    @classmethod
    def from_json(cls, file_path, out_fpath):
        conf = json.load(open(file_path, 'r'))
        fp = open(out_fpath, 'w')
        return cls(conf, fp)

    def init_vars(self):
        self.karg_addr = "sgprKernArgAddress"
        self.wg0 = "sgprWorkGroup0"
        self.wg1 = "sgprWorkGroup1"
        self.wg2 = "sgprWorkGroup2"
        self.acc_regs = 'vgprAcc'
        self.alpha = 'sgprAlpha'
        self.src_C = 'vgprValuC1'
        general = getattr(self, 'general')
        self.dtype = general['dtype']
        b_k_dt = general['mfma'].split('x')
        self.mfma_block0 = eval(b_k_dt[0])
        self.mfma_block1 = eval(b_k_dt[1])
        self.mfma_k = eval(b_k_dt[2][:1])
        self.elem_per_dword, self.elem_len = dtype_size(self.dtype)
        self.glvw = self.glvw0 = self.glvw1 = general['glvw']
        self.lvca = self.mfma_block0 // (self.glvw0 * self.elem_per_dword)
        self.lvcb = self.mfma_block1 // (self.glvw1 * self.elem_per_dword)
        self.threadtile0 = (64 // self.lvca) # wavefront: 64
        self.threadtile1 = (64 // self.lvcb)
        self.MT0 = general['MT0']
        self.MT1 = general['MT1']
        self.subgrp0 = self.MT0 // 4 # 4 simds
        self.subgrp1 = self.MT1 // 4
        self.vw0 = self.subgrp0 // self.threadtile0
        self.vw1 = self.subgrp1 // self.threadtile1
        self.depthU = general['depthU']
        self.rw_len_per_wave = 64 * general['glvw'] * self.elem_per_dword * self.elem_len
        self.tmp_regs = "vgprTmp"
        self.mac_unroll_cnt = self.depthU // self.mfma_k
        if self.MT0 == 64 and self.MT1 == 128:
            self.mfma_blocks0, self.mfma_blocks1 = 2, 1
        self.mfma_reg_len = get_mfma_info(getattr(self, 'general')['mfma'])
        self.mfma_lane_len = 8
        self.mfma_instr = 'f32_' + getattr(self, 'general')['mfma']

    def load_karg(self, var, dw=1):
        self.s_load(var, self.karg_addr, getattr(self, 'kargs')[var], dw=dw)

    def cvt2bytes(self, var):
        self.v_lshl(var, to_shift_bit(self.elem_len), var)

    def size2dtype(self, sz:int):
        dw = sz // 4 # dwords
        dtype = 'b128' if dw == 4 else 'b64' if dw == 2 else 'b32'
        return dtype, dw

    def define_vars(self, var_dict:dict=None):
        for k in ['sgpr', 'vgpr']:
            self.comments("Define %s variables" % k, tab=0)
            for _k, _v in getattr(self, k).items():
                self.def_var(_k, _v)
            self.empty_line()

        self.def_var('BufferLimit', '0x80000000', cmt='2GB limit - set offsets to -1 to exceed this and clamp')
        self.def_var('Srd127_96', '0x20000', cmt='Bits 127:96 of SRD.  Set DataFormat = 32 bit')
        self.def_var('roundMaskVal', '0xffff0000')
        self.empty_line()

        # lds variables
        self.comments("Define lds variables", tab=0)
        self.pad = 8
        self.def_var('varlds_pad', self.pad)
        self.def_var('varlds_Asize_per_wr', self.rw_len_per_wave + self.pad, cmt='256 + varlds_pad')
        self.def_var('varlds_Asize_per_wave', 'varlds_Asize_per_wr * %d' % self.vw0)
        self.def_var('varlds_Asize_per_wg', 'varlds_Asize_per_wave * 4')
        self.def_var('varlds_Bsize_per_wr', self.rw_len_per_wave + self.pad, cmt='256 + varlds_pad')
        self.def_var('varlds_Bsize_per_wave', 'varlds_Bsize_per_wr * %d' % self.vw1)
        self.def_var('varlds_Bsize_per_wg', 'varlds_Bsize_per_wave * 4')
        self.def_var('varA_lds_base_addr', 0)
        self.def_var('varB_lds_base_addr', 'varA_lds_base_addr + varlds_Asize_per_wg * 2')
        self.empty_line()

        self.write_line('function v_regs(base, offset)', tab=0)
        self.write_line('var v_idx')
        self.write_line('v_idx = base + offset')
        self.write_line('return v[v_idx]')
        self.write_line('end', tab=0, nl=True)

        self.write_line('function s_regs(base, offset)', tab=0)
        self.write_line('var s_idx')
        self.write_line('s_idx = base + offset')
        self.write_line('return s[s_idx]')
        self.write_line('end', tab=0, nl=True)
        return self

    def setup_hw_args(self):
        self.write_line('shader main', tab=0)
        self.write_line('type(CS)')
        self.write_line('user_sgpr_count(14)')
        self.write_line('tgid_x_en(1)')
        self.write_line('tgid_y_en(1)')
        self.write_line('tgid_z_en(1)')
        self.write_line('tidig_comp_cnt(2)')
        self.empty_line()
        return self

    def footer(self):
        self.create_label('finish')
        self.waitcnt(0)
        self.end_pgm()
        self.empty_line()
        self.write_line('end', tab=0)
        self.empty_line()
        return self

    def get_tid(self):
        #vgprSerial    holds threadIdx
        #vgprSerial+1  holds threadIdx of wavefront (0-63)
        #vgprSerial+2  holds threadIdy  (simd= 0,1,2,3)
        #vgprSerial+3  holds threadIdZ  (wave0 =0 wave1 = 1)
        self.serial_tid = serial_tid = 'vgprSerial'
        self.tid = tid = 'vgprSerial+1'
        simd_id = 'vgprSerial+2'
        wave_id = 'vgprSerial+3'

        self.v_mov(serial_tid, 'v0')
        self.v_mask(tid, serial_tid, '0x3f')

        #HW_ID_REG
        #bit[0-3] #waveId
        #bit[5-4] #simdId
        #bit[11-8] #CuId
        hw_id = 'sgprHWID'
        self.read_hwreg(hw_id, 'HW_REG_HW_ID')
        self.v_mask('v4', '0x30', hw_id)  # simd
        self.v_lshr(simd_id, 4, 'v4')
        self.vgpr2sgpr('sgprFetchSubGrpId', simd_id)
        self.simd_id = 'sgprFetchSubGrpId'
        self.v_mask(wave_id, '0xf', hw_id) # waveid
        self.vgpr2sgpr('sgprHWID+1', wave_id)
        self.wave_id = 'sgprHWID+1'
        self.empty_line()

    def fetch(self, lds=True):
        self.update_lds_ptr()
        for i in range(self.vw):
            self.buffer_load((self.g2l, i), (self.g_r_addr, i),
                    self.srd, lds=lds,
                    offset='%s * %d' % (self.rw_len_per_wave, i))
        self.empty_line()
        return self.vw

    def update_lds_ptr(self, **kwargs):
        self.comments('set lds base address to %s' % self.next_lds_ptr)
        self.set_lds_addr(self.next_lds_ptr, **kwargs)
        self.next_lds_ptr = self.l_w_addr1 if self.next_lds_ptr == self.l_w_addr0 else self.l_w_addr0
        self.empty_line()

    def unroll_fetch(self, cnt=0):
        for i in range(2): # ping pang
            self.comments('unroll loop %d' % i, bar=True, nl=True)
            self.barrier(cmt='wait for update A[%d] & B[%d]' % (i, i), nl=True)
            cnt += self.a.fetch()
            cnt += self.b.fetch()
            cnt = self.a.wait4fetch(cnt)
            self.a.update_fetch_addr(prio=1)
            cnt = self.b.wait4fetch(cnt)
            self.b.update_fetch_addr(prio=1)

    def fetch_phase(self):
        self.load_karg('sgprAddressA', 4) # load both A&B
        self.load_karg('sgprStridesA', 4) # load both A&B
        self.load_karg('sgprTensor2dSizeA', 4) # load both A&B
        self.load_karg('sgprSizesSum')
        self.empty_line()

        self.get_tid()

        self.cmp_jmp('wave0_entry_start', self.wave_id, 1)

        # wait for load kern args
        self.waitcnt(0, 'lgkm')
        self.empty_line()

        a = Tensor(self.conf, self.fp, 'A')
        b = Tensor(self.conf, self.fp, 'B')
        self.a, self.b = a, b

        a.create_descriptor()
        a.global_mem_addressing()

        b.create_descriptor()
        b.global_mem_addressing()

        self.comments('Global Fetch A & B', bar=True, nl=True)
        self.barrier(cmt='sync up for beginning')
        self.empty_line()

        # ping
        cnt = a.fetch()
        cnt += b.fetch()
        a.update_fetch_addr()
        b.update_fetch_addr()

        # pang
        cnt += a.fetch()
        cnt += b.fetch()
        a.update_fetch_addr()
        b.update_fetch_addr()

        # wait for A & B ready
        cnt = a.wait4fetch(cnt)
        cnt = b.wait4fetch(cnt)

        # unroll loop
        self.unroll_loop('fetch_loop', partial(self.unroll_fetch, cnt), k=self.depthU, end=-2, step=2)

        self.waitcnt(8, 'vm')
        self.barrier(cmt='A[1] is ready')
        self.waitcnt(0, 'vm')
        self.barrier(cmt='B[1] is ready')
        self.end_pgm()
        self.empty_line()
        self.empty_line()
        return self

    def mac_phase(self):
        self.create_label('wave0_entry_start')
        self.comments('hide all kern args load latency with ACC VGPR initialization')
        self.for_loop(32, partial(self.v_accvgpr, ('vgprAcc', 'i'), 0, 0, op='write'))

        self.load_karg('sgprTensor2dSizeC', 2)
        self.load_karg('sgprAlpha', 4)
        self.load_karg('sgprStridesD', 4)
        self.load_karg('sgprAddressD', 4)
        self.empty_line()

        self.a.local_mem_addressing()

        self.barrier(cmt='sync up for fetch A[0]', nl=True)

        self.b.local_mem_addressing()
        
        self.waitcnt(0, 'lgkm', cmt='wait for kernel variables ready', nl=True)

        self.c = c = Tensor(self.conf, self.fp, 'C')
        self.d = d = Tensor(self.conf, self.fp, 'D')
        c.create_descriptor()
        d.create_descriptor()

        c.global_mem_addressing()

        if self.dtype == 'fp16':
            mac_op = MACOperator(self.conf, self.fp, self.a, self.b, self.c)
        elif self.dtype == 'bf16':
            mac_op = MACOperatorBF16(self.conf, self.fp, self.a, self.b, self.c)

        mac_op.matmul()

        return self


class Tensor(KernGenerator):
    def __init__(self, conf:dict, fp, mat:str):
        super().__init__(conf, fp)
        self.set_var_alias(mat)
        self.pingpang = 0
        self.pop_instrs_cnt = 0

    def set_var_alias(self, mat):
        setattr(self, 'g2l', 'vgprG2L' + mat)
        setattr(self, 'g_r_addr', 'vgprGlobalReadOfvar' + mat)
        setattr(self, 'g_w_addr', 'vgprGlobalWriteOfvar' + mat)
        setattr(self, 'g_r_offset', 'sgprScalarGlobalReadOffset' + mat)
        setattr(self, 'l_w_addr0', 'sgprLocalWriteAddr' + mat)
        setattr(self, 'l_w_addr1', 'sgprLocalWriteAddr%s+1' % mat)
        setattr(self, 'l_r_addr0', 'vgprLocalReadAddr' + mat)
        setattr(self, 'l_r_addr1', 'vgprLocalReadAddr%s+1' % mat)
        if mat == 'C':
            setattr(self, 'regs', 'vgprValu' + mat)
        else:
            setattr(self, 'regs', 'vgprValu%s_X0_I0' % mat)
        setattr(self, 'src', 'sgprAddress' + mat)
        setattr(self, 'srd', 'sgprSrd' + mat)
        setattr(self, 'stride0', 'sgprStrides' + mat)
        setattr(self, 'stride1', 'sgprStrides%s+1' % mat)
        setattr(self, 'rw_len_per_wave', 'varlds_%ssize_per_wr' % mat)
        setattr(self, 'rw_len_per_subgrp', 'varlds_%ssize_per_wave' % mat)
        setattr(self, 'rw_len_per_wg', 'varlds_%ssize_per_wg' % mat)
        setattr(self, 'lds_base_addr', 'var%s_lds_base_addr' % mat)
        self.mat = mat
        self.mt = self.MT0 if mat == 'A' else self.MT1
        self.vw = self.vw0 if mat == 'A' else self.vw1
        self.glvw = self.glvw0 if mat == 'A' else self.glvw1
        self.mfma_block = self.mfma_block0 if mat == 'A' else self.mfma_block1
        self.wg_id = self.wg0 if mat == 'A' else self.wg1
        self.subgrp = self.subgrp0 if mat == 'A' else self.subgrp1
        self.lane_len = self.lvca if mat == 'A' else self.lvcb
        self.threadtile = self.threadtile0 if mat == 'A' else self.threadtile1
        self.simd_id = 'sgprFetchSubGrpId'
        self.tid = 'vgprSerial+1'
        self.vmcnt = self.vw
        self.mfma_blocks = self.mfma_blocks0 if mat == 'A' else self.mfma_blocks1
        self.lds_read_dw = self.mfma_reg_len[2] if mat == 'A' else self.mfma_reg_len[3]

    def create_descriptor(self):
        self.comments('Create Tensor Descriptor of %s' % self.mat, bar=True, nl=True)
        self.s_mov(self.srd, self.src, cmt='sgpr[0-1] - base address')
        self.s_mov((self.srd, 1), (self.src, 1))
        self.s_mov((self.srd, 2), 'BufferLimit', cmt='sgpr[2]   - limit')
        self.s_mov((self.srd, 3), 'Srd127_96', cmt='sgpr[3]   - attributes')
        self.empty_line()
        return self

    def global_mem_addressing(self):
        self.comments('Global memory addressing of %s' % self.mat, bar=True, nl=True)
        if self.mat == 'C' or self.mat == 'D':
            return self.calc_C()

        # start address of workgroup
        wg_addr, wave_addr = 's84', 's85'
        self.comments('%s: address of workgroup' % wg_addr)
        self.s_mul(wg_addr, self.stride0, self.mt)
        self.s_mul(wg_addr, self.wg_id, wg_addr)

        # start address of wave
        self.comments('%s: address of wave' % wave_addr)
        self.s_mul(wave_addr, self.stride0, self.subgrp)
        self.s_mul(wave_addr, self.simd_id, wave_addr)
        self.s_add(wave_addr, wg_addr, wave_addr, dtype='u32')

        # start address of threadtile
        lane_id, thread_addr, lane_addr = 'v0', 'v1', 'v4'
        self.comments('%s: address of lane' % lane_addr)
        self.v_lshr(lane_id, to_shift_bit(self.lane_len), self.tid)
        self.v_mul(lane_addr, self.stride0, lane_id, dtype='u32')
        self.v_add(lane_addr, lane_addr, wave_addr, dtype='u32')

        # start address of thread
        self.comments('%s: address of thread' % thread_addr)
        self.v_mask(thread_addr, self.lane_len - 1, self.tid)
        self.v_lshl(thread_addr, to_shift_bit(self.elem_per_dword), thread_addr, cmt='scale elements per dword')

        self.comments('%s: global read address' % self.g_r_addr)
        self.v_add(self.g_r_addr, lane_addr, thread_addr, dtype='u32', carry_out=True)
        self.cvt2bytes(self.g_r_addr)
        self.empty_line()

        self.comments('%s: offset of vector width' % self.g_r_offset)
        # 4 lanes * 2 bytes per element, next read from 5th lane
        self.s_lshl(self.g_r_offset, self.stride0, to_shift_bit(self.threadtile) +  to_shift_bit(self.elem_len))
        self.s_sub(self.g_r_offset, self.g_r_offset, self.rw_len_per_wave, dtype='u32')
        for i in range(1, self.vw):
            self.v_add((self.g_r_addr, i), self.g_r_offset, (self.g_r_addr, i - 1), dtype='u32')
        self.empty_line()

        self.comments('set local write address')
        self.s_mov(self.l_w_addr0, self.rw_len_per_subgrp)
        self.s_mul(self.l_w_addr0, self.simd_id, self.l_w_addr0)
        self.s_add(self.l_w_addr0, self.l_w_addr0, self.lds_base_addr, dtype='u32')
        self.next_lds_ptr = self.l_w_addr0 
        self.s_add(self.l_w_addr1, self.rw_len_per_wg, self.l_w_addr0, dtype='u32')
        self.empty_line()

    def local_mem_addressing(self):
        # all wave load the same A, 4 waves load 4 Bs
        # map threads to 32 lanes on LDS
        self.comments('Local memory addressing of %s' % self.mat, bar=True, nl=True)
        self.comments('locate the address of lane/threadtile')
        tid = 'v1'
        self.v_mask(tid, self.tid, self.mfma_block - 1) # tid of wavefront mask mfma block, if block = 32, then 2 threads per lane
        self.v_mul(self.l_r_addr0, self.mfma_block, tid, dtype='u32') # map to column
        self.empty_line()

        # calc pad length
        pad_len, pad = 'v2', 'varlds_pad'
        self.v_lshr(pad_len, 2, tid) # a pad follow by 4 wr
        self.v_mul(pad_len, pad, pad_len, dtype='u32')
        self.empty_line()

        # 2 threads map to 1 lane, read threadtile elements per thread
        tid_lane = 'v1'
        self.comments('locate the address of specify thread')
        self.v_lshr(tid_lane, to_shift_bit(self.mfma_block), self.tid)
        self.v_lshl(tid_lane, to_shift_bit(self.elem_per_dword * 2), tid_lane, cmt='read 2 dwords per thread')
        self.v_add(self.l_r_addr0, tid_lane, self.l_r_addr0, dtype='u32')
        self.cvt2bytes(self.l_r_addr0)
        self.empty_line()

        # add pad
        self.comments('add padding length')
        self.v_add(self.l_r_addr0, self.l_r_addr0, pad_len, dtype='u32')
        self.empty_line()

        # address subgrp of B, 1 wave of A can boardcast to all 4 waves of B
        if self.mat == 'B':
            subgrp_addr = 's84'
            self.comments('4 waves load 4 B, %s: address of wave' % subgrp_addr)
            self.s_mul(subgrp_addr, self.simd_id, self.rw_len_per_subgrp)
            self.v_add(self.l_r_addr0, subgrp_addr, self.l_r_addr0, dtype='u32')
            self.empty_line()

        # add title offset to base addr
        self.v_add(self.l_r_addr0, self.lds_base_addr, self.l_r_addr0, dtype='u32')
        self.v_add(self.l_r_addr1, self.rw_len_per_wg, self.l_r_addr0, dtype='u32')
        self.empty_line()

    def calc_C(self):
        # calc workgroup address on y dim
        wg_addr, wg_hi_addr, wg_lo_addr = 's[84:85]', 's85', 's84'
        self.comments('[%s:%s]: address of workgroup on y dim' % (wg_hi_addr, wg_lo_addr))
        self.s_mul(wg_hi_addr, self.MT1, self.wg1)
        self.s_mul(wg_lo_addr, wg_hi_addr, self.stride0)
        self.s_mul(wg_hi_addr, wg_hi_addr, self.stride0, hi=True, dtype='u32')
        self.s_lshl(wg_addr, wg_addr, to_shift_bit(self.elem_len), dtype='b64', cmt='cvt2bytes')
        self.s_add(self.srd, self.srd, wg_lo_addr, dtype='u32')
        self.s_add((self.srd, 1), (self.srd, 1), wg_hi_addr, carry_out=True, dtype='u32')
        self.empty_line()
        self.write_line('s_add_u32       s[sgprSrdD+0], s[sgprSrdD+0], s84', tab=1)
        self.write_line('s_addc_u32       s[sgprSrdD+1], s[sgprSrdD+1], s85', tab=1)

        # calc workgroup address on z dim
        self.comments('[%s:%s]: address of workgroup on z dim' % (wg_hi_addr, wg_lo_addr))
        self.s_mul(wg_hi_addr, self.wg2, self.stride1, hi=True, dtype='u32')
        self.s_mul(wg_lo_addr, self.wg2, self.stride1)
        self.s_lshl(wg_addr, wg_addr, to_shift_bit(self.elem_len), dtype='b64', cmt='cvt2bytes')
        self.s_add(self.srd, self.srd, wg_lo_addr, dtype='u32')
        self.s_add((self.srd, 1), (self.srd, 1), wg_hi_addr, carry_out=True, dtype='u32')
        self.write_line('s_add_u32       s[sgprSrdD+0], s[sgprSrdD+0], s84', tab=1)
        self.write_line('s_addc_u32       s[sgprSrdD+1], s[sgprSrdD+1], s85', tab=1)
        self.empty_line()

        # remap z dim to x dim
        # use z dim to re-map threadIdx using for calculating waveId start off set for MAC wves to store 'C'
        self.comments('use z dim to re-map threadIdx using for calculating waveId start off set for MAC wves to store C')
        self.serial_tid = 'vgprSerial'
        self.v_lshl(self.serial_tid, 6, (self.serial_tid, 2), cmt='threadIdx = simdId<<6')
        self.v_add(self.serial_tid, self.tid, self.serial_tid, dtype='u32', cmt='threadIdx = threadIdx + 0-63')
        self.v_mul('v4', self.mfma_block, (self.serial_tid, 2), dtype='u32', cmt='scale by sub-tile-size 32 (B-tile/128)')
        self.v_mul('v3', 'v4', self.stride0, dtype='u32', cmt='wavestart vgpr')
        self.v_mask('v4', '0x1f', self.serial_tid, cmt='vectorStaticDiv vgprTmp = vgprSerial % 31')
        self.v_mul('v5', 'v4', self.stride0, dtype='u32', cmt='rowstart VGPR')
        self.v_mask('v4', '0x3f', self.serial_tid, cmt='vectorStaticDiv vgprTmp = vgprSerial % 63')
        self.v_lshr('v6', 5, 'v4', cmt='vectorStaticDiv vgprTmp = vgprSerial / 32')
        self.v_lshl('v6', 2, 'v6', cmt='*4')
        self.v_add((self.tmp_regs, 1), 'v3', 'v5', dtype='u32')
        self.empty_line()

        # calc workgroup address on x dim 
        self.s_mul(wg_lo_addr, self.MT0, self.wg0)
        self.v_add(self.tmp_regs, wg_lo_addr, 'v6', carry_out=True, dtype='u32')
        self.v_add_lshl(self.g_w_addr, self.tmp_regs, (self.tmp_regs, 1),
                to_shift_bit(self.elem_len), cmt='base_addr = wave_start+row_start scaled by BPE')
        self.empty_line()

    def update_fetch_addr(self, prio=0):
        self.comments('increment global address of %s to next iteration' % self.mat)
        offset = self.depthU * self.glvw * self.elem_per_dword

        # update to next iteration 
        if prio:
            self.setprio(prio)
        for i in range(self.vw):
            self.v_add((self.g_r_addr, i), offset, (self.g_r_addr, i), dtype='u32')
        if prio:
            self.setprio(0)
        self.empty_line()

    def wait4fetch(self, res_cnt=0):
        #self.waitcnt(20 if self.mat == 'A' else 12, 'vm')
        res_cnt = max(res_cnt - self.vmcnt, 0)
        self.waitcnt(res_cnt, 'vm')
        self.barrier(cmt='%s[%d] ready' % (self.mat, self.pingpang))
        self.pingpang = 1 if self.pingpang == 0 else 0
        self.empty_line()
        return res_cnt

    def push_lds_instrs(self):
        subgrp_offset = self.rw_len_per_subgrp + ' * 2'
        lane_len = self.mfma_k * self.mfma_blocks
        assert self.mfma_reg_len[2] == self.mfma_reg_len[3]
        rw_len = 64 // self.mfma_block * self.mfma_reg_len[2] * 4
        self.lds_instrs = []
        for k in [0, 1]: # pingpang
            offset = 0
            for i in range(self.mac_unroll_cnt):
                for j in range(self.mfma_blocks):
                    self.lds_instrs.append((
                        (self.regs, k * lane_len + j * self.mfma_lane_len + i * self.lds_read_dw),
                        (self.l_r_addr0, k),
                        '%s%d' % ('%d * %s + ' % (j, subgrp_offset) if j else '', offset),
                        dw_str(self.lds_read_dw)))
                offset += rw_len
        self.lds_instrs.reverse() # for pop
        self._lds_instrs = copy.copy(self.lds_instrs)
        return 2 * self.mac_unroll_cnt * self.mfma_blocks

    def pop_lds_instrs(self, cnt=1, auto_fill=True):
        if auto_fill:
            if len(self.lds_instrs) == 0 or len(self.lds_instrs) < cnt:
                self.lds_instrs = copy.copy(self._lds_instrs) + self.lds_instrs
                #self.barrier(nl=True, cmt='%s is ready' % self.mat)
        else:
            cnt = min(cnt, len(self.lds_instrs))
        for i in range(cnt):
            self.ds_read(*self.lds_instrs.pop())
        self.pop_instrs_cnt += cnt

    def read_acc_regs(self, cnt, dest=0, offset=0):
        cb = partial(self.v_accvgpr, (self.regs, 'i'),
                (self.acc_regs, 'i + %d' % offset if offset else 'i'), 0)
        self.for_loop(dest + cnt, cb, start=dest)


class MACOperator(KernGenerator):
    def __init__(self, conf:dict, fp, a, b, c):
        super().__init__(conf, fp)
        self.a, self.b, self.c = a, b, c
        # mfma blocks in two directions
        self.a.push_lds_instrs()
        self.b.push_lds_instrs()
        self.push_mfma_instrs()
        self.push_store_instrs()

    def push_store_instrs(self):
        lane_len = self.mfma_reg_len[0]
        n = lane_len // 2 # for fp16 and bf16, fixme for fp32
        self.store_dw, src_dw = 2, 2
        store_offset = self.store_dw * src_dw * 4
        accreg_offset, offset = 0, 0
        self.store_instrs = []
        self.num_mfma_blocks = self.mfma_blocks1 * self.mfma_blocks0
        for i in range(self.num_mfma_blocks):
            for o in range(0, n, self.store_dw):
                self.store_instrs.append((accreg_offset, o, offset, self.store_dw))
                offset += store_offset
            accreg_offset += lane_len
        self.store_instrs.reverse()

    def push_mfma_instrs(self):
        lane_len0 = self.mfma_lane_len * self.mfma_blocks0
        lane_len1 = self.mfma_lane_len * self.mfma_blocks1
        assert self.mfma_reg_len[2] == self.mfma_reg_len[3]
        rw_len = 64 // self.mfma_block0 * self.mfma_reg_len[2] * 4
        self.mfma_instrs = []
        d_off, c_off, a_off, b_off = self.mfma_reg_len
        for k in [0, 1]: # pingpang
            for i in range(self.mac_unroll_cnt):
                blk_off = 0
                for l in range(self.mfma_blocks1):
                    for j in range(self.mfma_blocks0):
                        self.mfma_instrs.append(((self.acc_regs, blk_off),
                            (self.a.regs, k * lane_len0 + j * self.mfma_lane_len + i * a_off),
                            (self.b.regs, k * lane_len1 + l * self.mfma_lane_len + i * b_off),
                            (self.acc_regs, blk_off), self.mfma_instr))
                        blk_off += d_off
        self.mfma_instrs.reverse() # for pop
        self._mfma_instrs = copy.copy(self.mfma_instrs)
        return 2 * self.mac_unroll_cnt * self.mfma_blocks0 * self.mfma_blocks1

    def pop_mfma_instrs(self, cnt=1, auto_fill=True):
        if auto_fill:
            if len(self.mfma_instrs) == 0 or len(self.mfma_instrs) < cnt:
                self.mfma_instrs = copy.copy(self._mfma_instrs) + self.mfma_instrs
        else:
            cnt = min(len(self.mfma_instrs), cnt)
        for i in range(cnt):
            self.v_mfma(*self.mfma_instrs.pop())

    def calc_interleave_info(self):
        self.num_instrs_A = len(self.a.lds_instrs) // 2 # pingpang / 2 == ping or pang
        self.num_instrs_B = len(self.b.lds_instrs) // 2 # pingpang / 2 == ping or pang
        self.num_mfma_instrs = len(self.mfma_instrs) // 2
        assert self.num_instrs_A % 4 == self.num_instrs_B % 4 == 0
        self.num_instrs_once_A = 4 if self.num_instrs_A > 4 else 2
        self.num_instrs_once_B = 4 if self.num_instrs_B > 4 else 2
        self.num_interleave_instrs_A = self.num_instrs_A // self.num_instrs_once_A
        self.num_interleave_instrs_B = self.num_instrs_B // self.num_instrs_once_B
        self.num_remain_instrs = self.num_mfma_instrs - self.num_interleave_instrs_A - self.num_interleave_instrs_B
        self.num_store_instrs_one_block = len(self.store_instrs)

    def read_A(self, interleave=True):
        if interleave: self.waitcnt(0, 'lgkm')
        for _ in range(0, self.num_instrs_A, self.num_instrs_once_A):
            if interleave: self.pop_mfma_instrs() # no need wait_lgkmcnt
            self.a.pop_lds_instrs(self.num_instrs_once_A)
        self.empty_line()

    def read_B(self):
        wcnt = 0
        for i, _ in enumerate(range(0, self.num_instrs_B, self.num_instrs_once_B)):
            self.b.pop_lds_instrs(self.num_instrs_once_B)
            wcnt += self.num_instrs_once_B - 1
            if i % 2 == 0: self.waitcnt(wcnt, 'lgkm')
            self.pop_mfma_instrs()
        self.empty_line()

    def do_math(self):
        wcnt = self.num_remain_instrs // 2
        for i in range(0, self.num_remain_instrs, 2):
            self.waitcnt(wcnt, 'lgkm')
            self.pop_mfma_instrs(2)
            wcnt -= 1
        self.empty_line()

    def matmul(self):
        # head
        # a: 16, b: 8, mfma: 16
        self.calc_interleave_info()

        self.barrier(cmt='A[0] is ready', nl=True)
        self.read_A(False)

        self.barrier(cmt='B[0] is ready', nl=True)
        self.read_B()

        self.barrier(cmt='wait for update A[0] & B[0]', nl=True)
        self.do_math()

        self.barrier(cmt='A[1] is ready', nl=True)
        self.read_A()

        self.barrier(cmt='B[1] is ready', nl=True)
        self.read_B()

        self.barrier(cmt='wait for update A[1] & B[1]', nl=True)
        self.do_math()

        self.barrier(cmt='A[0] is ready', nl=True)
        self.read_A()

        self.barrier(cmt='B[0] is ready', nl=True)
        self.b.pop_lds_instrs(2)

        # loop
        self.unroll_loop('MAC_loop', self.unroll_matmul, step=2, end=-4)

        # tail, 2 barrier needed
        self.waitcnt(1, 'lgkm')
        self.pop_mfma_instrs()
        self.b.pop_lds_instrs(2)
        self.pop_mfma_instrs()

        self.do_math()

        self.barrier(cmt='A[1] is ready', nl=True)
        self.read_A()

        self.barrier(cmt='B[1] is ready', nl=True)
        self.read_B()

        self.store_C()

        # all instruction lists should be empty.
        # pdb.set_trace()
        assert len(self.a.lds_instrs) == len(self.b.lds_instrs) == len(self.mfma_instrs) == len(self.store_instrs) == 0

    def unroll_matmul(self):
        for i in range(2):
            self.comments('unroll loop %d' % i, bar=True, nl=True)

            self.waitcnt(1, 'lgkm')
            self.pop_mfma_instrs()
            self.b.pop_lds_instrs(2)
            self.pop_mfma_instrs()

            self.barrier(cmt='wait for update A[%d] & B[%d]' % (i, i), nl=True)
            self.do_math()

            self.barrier(cmt='A[%d] is ready' % (1 if i == 0 else 0), nl=True)
            self.read_A()

            self.barrier(cmt='B[%d] is ready' % (1 if i == 0 else 0), nl=True)
            self.b.pop_lds_instrs(2)

    def merge_fp32(self, i):
        a = i * 2
        b = a + 1
        self.c.fp16((self.c.regs, a))
        self.c.fp16((self.c.regs, b))
        self.c.v_lshl_or((self.c.regs, i), (self.c.regs, b), 16, (self.c.regs, a))
        self.c.v_pk_mul((self.c.regs, i), self.c.alpha, (self.c.regs, i))

    def pop_store_instrs(self, cnt=1):
        for _ in range(cnt):
            acc_reg_offset, i, offset, dw = self.store_instrs.pop()
            self.c.read_acc_regs(dw * 2, dest=i * dw, offset=acc_reg_offset)
            self.empty_line()
            self.merge_fp32(i)
            self.merge_fp32(i + 1)
            self.empty_line()
            self.buffer_store((self.c.regs, i), self.c.g_w_addr,
                    self.c.srd, dw, offset=offset)
            self.empty_line()
            self.pop_mfma_instrs(auto_fill=False)

    def reorder_mfma_instrs(self):
        # reorder mfma instrs by block number, reverse=True
        instrs = collections.defaultdict(lambda : [])
        for o in self.mfma_instrs:
            instrs[o[0][1]].append(o)
        self.mfma_instrs = []
        for i in sorted(instrs.keys(), reverse=True):
            self.mfma_instrs += instrs[i]

    def get_next_mfma_instr_blk(self):
        return self.mfma_instrs[-1][0][1]

    def get_next_store_instr_blk(self):
        return self.store_instrs[-1][0]

    def store_C(self):
        n = len(self.store_instrs) // self.num_mfma_blocks
        block_offset = self.mfma_reg_len[0] * 4
        num_store_instrs = len(self.store_instrs) // self.num_mfma_blocks

        # reorder mfma instrs by block number
        self.reorder_mfma_instrs()

        self.comments('Store C', bar=True, nl=True)
        self.waitcnt(0, 'lgkm')

        for i in range(self.num_mfma_blocks):
            self.pop_mfma_instrs(auto_fill=False)
            for j in range(4):
                self.buffer_load((self.src_C, j * self.store_dw),
                        self.c.g_w_addr, self.c.srd, self.store_dw,
                        offset=i * block_offset + j * self.store_dw * 4 * 2)
            self.pop_mfma_instrs(auto_fill=False)
            self.empty_line()

            if len(self.mfma_instrs) > 0:
                blk = self.get_next_store_instr_blk()
                while self.get_next_mfma_instr_blk() <= blk:
                    self.pop_mfma_instrs(auto_fill=False)
                    self.empty_line()

            self.waitcnt(4 - 1, 'vm')
            self.pop_store_instrs(num_store_instrs)


class MACOperatorBF16(MACOperator):
    def matmul(self):
        self.barrier(cmt='wait for A[0] is ready', nl=True)

        self.a.pop_lds_instrs(16)

        self.barrier(cmt='wait for B[0] is ready', nl=True)

        self.b.pop_lds_instrs(4)

        self.waitcnt(3, 'lgkm')

        self.pop_mfma_instrs()
        self.b.pop_lds_instrs(4)
        self.pop_mfma_instrs()
        self.barrier()

        self.waitcnt(6, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(5, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(4, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(0, 'lgkm')
        self.pop_mfma_instrs(2)
        self.setprio(0)
        self.pop_mfma_instrs()
        self.barrier()
        self.a.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(4)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(5)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(5)
        self.pop_mfma_instrs()
        self.barrier()

        self.b.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.b.pop_lds_instrs(4)
        self.setprio(1)

        self.waitcnt(5, 'lgkm')
        self.pop_mfma_instrs()
        self.b.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.barrier()
        self.waitcnt(6, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(5, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(4, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(0, 'lgkm')
        self.pop_mfma_instrs(2)
        self.setprio(0)
        self.pop_mfma_instrs()
        self.barrier()
        self.a.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(5)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(4)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(5)
        self.pop_mfma_instrs()
        self.barrier()

        self.b.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.b.pop_lds_instrs(4)
        self.setprio(1)
        self.empty_line()

        # mac loop
        self.unroll_loop('MAC_loop', self.unroll_matmul, step=2, end=-4)

        # mac tail, no fetch at the same time
        self.waitcnt(1, 'lgkm')
        self.pop_mfma_instrs()
        self.b.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.waitcnt(6, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(5, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(4, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(0, 'lgkm')
        self.pop_mfma_instrs(3)
        self.barrier()
        self.a.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(4)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(5)
        self.pop_mfma_instrs()
        self.a.pop_lds_instrs(5)
        self.pop_mfma_instrs()
        self.barrier()
        self.b.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.b.pop_lds_instrs(4)
        self.empty_line()

        self.waitcnt(5, 'lgkm')

        self.pop_mfma_instrs()
        self.b.pop_lds_instrs(2)
        self.pop_mfma_instrs()
        self.waitcnt(6, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(5, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(4, 'lgkm')
        self.pop_mfma_instrs(2)
        self.waitcnt(0, 'lgkm')
        while len(self.mfma_instrs):
            self.pop_mfma_instrs()
        self.empty_line

        # all instruction lists should be empty.
        # pdb.set_trace()
        assert len(self.a.lds_instrs) == len(self.b.lds_instrs) == len(self.mfma_instrs) == 0

    def unroll_matmul(self):
        for _ in range(2):
            self.waitcnt(5, 'lgkm')
            self.pop_mfma_instrs()
            self.b.pop_lds_instrs(2)
            self.pop_mfma_instrs()
            self.barrier()
            self.waitcnt(6, 'lgkm')
            self.pop_mfma_instrs(2)
            self.waitcnt(5, 'lgkm')
            self.pop_mfma_instrs(2)
            self.waitcnt(4, 'lgkm')
            self.pop_mfma_instrs(2)
            self.waitcnt(0, 'lgkm')
            self.pop_mfma_instrs(2)
            self.setprio(0)
            self.pop_mfma_instrs()
            self.barrier()
            self.a.pop_lds_instrs(2)
            self.pop_mfma_instrs()
            self.a.pop_lds_instrs(4)
            self.pop_mfma_instrs()
            self.a.pop_lds_instrs(5)
            self.pop_mfma_instrs()
            self.a.pop_lds_instrs(5)
            self.pop_mfma_instrs()
            self.barrier()
            self.b.pop_lds_instrs(2)
            self.pop_mfma_instrs()
            self.b.pop_lds_instrs(4)
            self.setprio(1)
            self.empty_line()

    def merge_bf16(self, i):
        a = i * 2
        b = a + 1
        self.v_lshr((self.c.regs, a), 16, (self.c.regs, a))
        self.v_and_or((self.c.regs, i), (self.c.regs, b),
                (self.tmp_regs, 1), (self.c.regs, a))

    def pop_store_instrs(self, cnt=1):
        for _ in range(cnt):
            acc_reg_offset, i, offset, dw = self.store_instrs.pop()
            self.c.read_acc_regs(dw * 2, dest=i * dw, offset=acc_reg_offset)
            self.empty_line()
            self.merge_bf16(i)
            self.merge_bf16(i + 1)
            self.buffer_store((self.c.regs, i), self.c.g_w_addr, self.c.srd, dw, offset=offset)
            self.empty_line()
            self.pop_mfma_instrs(auto_fill=False)

    def store_C(self):
        self.write_line('s_mov_b32     s84, roundMaskVal')
        self.write_line('v_xor_b32     v[vgprTmp+1], v[vgprTmp],v[vgprTmp]')
        self.write_line('v_or_b32      v[vgprTmp+1], s84, v[vgprTmp+1]')
        self.empty_line
        super().store_C()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.description = "Replacement kernel generator"
    parser.add_argument("-f", "--config", type=str, help='specify config file path')
    parser.add_argument("-o", "--output", type=str, help='specify output file path')
    args = parser.parse_args()

    if not args.config:
        print('No config file specified, please use "--help" for more details.')
        exit(-1)

    if not args.output:
        out_fpath = Path(args.config).stem + '.sp3'

    KernGenerator.from_json(args.config, out_fpath).define_vars().setup_hw_args().fetch_phase().mac_phase().footer()

    print("[Output]: %s" % out_fpath)

