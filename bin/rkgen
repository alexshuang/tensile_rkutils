#!/usr/bin/env python3


import argparse
import json
import os
import pdb
#import numpy as np
#import pandas as pd
from pathlib import Path
from functools import partial


def def_vars(conf, wrt):
    # sgpr & vgpr variables
    wrt.comments('Define SGPR & VGPR variables')
    for k in ['sregs', 'vregs']:
        wrt.write_line("// %s define" % k)
        for k, v in conf[k].items():
            wrt.def_var(k, v)
        wrt.empty_line()

    wrt.def_var('BufferLimit', 0x80000000, cmt='2GB limit - set offsets to -1 to exceed this and clamp')
    wrt.def_var('Srd127_96', 0x20000, cmt='Bits 127:96 of SRD.  Set DataFormat = 32 bit')
    wrt.def_var('roundMaskVal', 0xffff0000)

    # lds variables
    pad = 8
    mt_h = conf['mt']['h']
    mt_w = conf['mt']['w']
    simd = conf['mfma']['simd']
    a_per_wr = 256 + pad
    lvca = int(32 / (conf['glvw'] * 2))
    rows_per_wave = int(mt_h / simd)
    a_vw = int(rows_per_wave / (64 / lvca))
    a_per_wave = a_per_wr * a_vw
    a_per_wg = a_per_wave * simd
    b_per_wr = 256 + pad
    lvcb = int(32 / (conf['glvw'] * 2))
    cols_per_wave = int(mt_w / simd)
    b_vw = int(cols_per_wave / (64 / lvcb))
    b_per_wave = b_per_wr * b_vw
    b_per_wg = b_per_wave * simd

    wrt.comments("Define lds vars")
    wrt.def_var('varlds_pad', pad)
    wrt.def_var('varlds_Asize_per_wr', a_per_wr, cmt='256 + varlds_pad')
    wrt.def_var('varlds_Asize_per_wave', 'varlds_Asize_per_wr * %d' % a_vw, cmt='vw == %d' % a_vw)
    wrt.def_var('varlds_Asize_per_wg', 'varlds_Asize_per_wave * %d' % simd)
    wrt.empty_line()
    wrt.def_var('varlds_Bsize_per_wr', b_per_wr, cmt='256 + varlds_pad')
    wrt.def_var('varlds_Bsize_per_wave', 'varlds_Bsize_per_wr * %d' % b_vw, cmt='vw == %d' % b_vw)
    wrt.def_var('varlds_Bsize_per_wg', 'varlds_Bsize_per_wave * %d' % simd)
    wrt.empty_line()
    wrt.def_var('varA_lds_base_addr', 0)
    wrt.def_var('varB_lds_base_addr', 'varA_lds_base_addr + varlds_Asize_per_wg * 2')
    wrt.empty_line()

    conf['lvca'] = lvca
    conf['lvcb'] = lvcb
    conf['A_VW'] = a_vw
    conf['B_VW'] = b_vw


def def_header(conf, wrt):
    wrt.write_line('shader main', tab=0)
    wrt.write_line('type(CS)')
    wrt.write_line('user_sgpr_count(14)')
    wrt.write_line('tgid_x_en(1)')
    wrt.write_line('tgid_y_en(1)')
    wrt.write_line('tgid_z_en(1)')
    wrt.write_line('tidig_comp_cnt(2)')
    wrt.empty_line()


def def_footer(conf, wrt):
    wrt.label('finish')
    wrt.waitcnt(0)
    wrt.end_pgm()
    wrt.empty_line()
    wrt.write_line('end', tab=0)
    wrt.empty_line()


def reg_str(s, start_off=0, end_off=0):
    if isinstance(s, str) and (s.startswith('v[') or s.startswith('s[')):
        return s
    if isinstance(s, int) or (isinstance(s, str) and s[0].isdigit()):
        return s
    if isinstance(s, tuple):
        s, *off = s
        start_off = off[0]
        if len(off) > 1: end_off = off[1]
    if not s.startswith('vgpr') and not s.startswith('sgpr'):
        return s
    dtype = 'v' if s.startswith('vgpr') else 's'
    if end_off != 0: 
        s = '%s+%s:%s+%s' % (s, start_off, s, end_off)
    elif start_off != 0:
        s = '%s+%s' % (s, start_off)
    return dtype + '[' + s + ']'


# load kernel args to sgpr
def load_karg(conf, wrt, var, dw=1):
    wrt.s_load(var, 'sgprKernArgAddress', conf['kargs'][var], dw=dw)


def var_str(*s):
    return '+'.join(str(o) for o in s)


def get_thread_info(conf, wrt):
    #vgprSerial    holds threadIdx
    #vgprSerial+1  holds WaveFrontId (0-63)
    #vgprSerial+2  holds threadIdy  (simd= 0,1,2,3)
    #vgprSerial+3  holds threadIdZ  (wave0 =0 wave1 = 1)
    tid = 'vgprSerial'
    wf_tid = var_str(tid, 1)
    simd_id = var_str(tid, 2)
    wave_id = var_str(tid, 3)

    wrt.v_mov(tid, 'v0')
    wrt.v_mask(wf_tid, tid, 64) # wave front id

    #HW_ID_REG
    #bit[0-3] #waveId
    #bit[5-4] #simdId
    #bit[11-8] #CuId
    hwid = 'sgprHWID'
    wrt.read_hwreg(hwid, 'HW_REG_HW_ID')
    wrt.v_mask('v4', '0x30', hwid)  # simd
    wrt.v_lshr(simd_id, 4, 'v4')
    wrt.v_mask(wave_id, '0xf', hwid) # waveid
    conf['vTID'] = tid
    conf['vWFTID'] = wf_tid
    conf['vSIMDID'] = simd_id
    conf['vWaveID'] = wave_id
    wrt.empty_line()


def create_branch(wrt, label, var, val, eq=False):
    svar = 'sgprHWID+1'
    wrt.vgpr2sgpr(svar, var)
    wrt.cmp_jmp(label, svar, val, eq=False)
    wrt.empty_line()


def set_addr_desc(wrt, mat):
    '''
    Global read addresses: address A resource descriptor set-up
    sgpr[0-1] - base address
    sgpr[2]   - limit
    sgpr[3]   - attributes
    '''
    src = 'sgprAddress' + mat
    dest = 'sgprSrd' + mat
    wrt.s_mov(dest, src)
    # (dest, 1) == dest+1
    wrt.s_mov((dest, 1), (src, 1))
    '''
    s_mov(fp, 'sgprShadowLimitA', 'sgprTensor2dSizeA', 'u32')
    s_mov(fp, 'sgprShadowLimitA+1', 'sgprTensor2dSizeA', 'u32')
    # convert to bytes
    s_lsh(fp, 'sgprShadowLimitA', 'sgprShadowLimitA', 1, ldir=True, dtype='b64')
    # pad by 4
    s_add(fp, 'sgprShadowLimitA', 'sgprShadowLimitA', 4, dtype='u32')
    s_add(fp, 'sgprShadowLimitA+1', 'sgprShadowLimitA+1', 0, carry_out=True, dtype='u32')
    s_cmp(fp, 'sgprShadowLimitA+1', 0)
    s_cselect(fp, 'sgprSrdA+2', 'sgprShadowLimitA', 'BufferLimit')
    '''
    wrt.s_mov((dest, 2), 'BufferLimit')
    wrt.s_mov((dest, 3), 'Srd127_96')
    wrt.empty_line()


def to_shift_bit(val):
    b, s = 0, 1
    while s < val:
        s *= 2
        b += 1
    return b


def global_address_assignment(conf, wrt, mat):
    wrt.comments('global address of %s' % mat)

    # set address A descriptor
    set_addr_desc(wrt, mat)

    dest = 'sgprLocalWriteAddr' + mat
    src = 'vgprGlobalReadOfvar' + mat
    off = 'sgprScalarGlobalReadOffset' + mat
    mat_stride = 'sgprStrides' + mat
    vw = conf[mat + '_VW']
    wg = 'sgprWorkGroup%d' % (0 if mat == 'A' else 1)

    # start read address of wave
    mt = conf['mt']['h'] if mat == 'A' else conf['mt']['w']
    wrt.s_mul('s84', mat_stride, mt)
    wrt.s_mul('s84', wg, 's84')
    wrt.vgpr2sgpr('sgprFetchSubGrpId', conf['vSIMDID'])
    wrt.s_mul('s85', mat_stride, int(mt / conf['mfma']['simd']))
    wrt.s_mul('s85', 'sgprFetchSubGrpId', 's85') # handle 16 rows per subgrp(wave)
    wrt.s_add('s84', 's84', 's85')

    wrt.empty_line()

    # tile offset assignment
    tid = conf['vWFTID']
    glvw = conf['glvw']
    lvca = conf['lvca']
    wrt.comments('LVCA=%d, vw=-1' % lvca)
    wrt.v_lshr('v0', to_shift_bit(lvca), tid)
    wrt.v_mul('v4', mat_stride, 'v0', dtype='u32')
    wrt.v_mask('v1', lvca - 1, tid)
    wrt.cvt2byte('v1')
    wrt.v_add(src, 'v4', 'v1', dtype='u32', carry_out=True)
    wrt.v_add(src, src, 's84', dtype='u32')
    wrt.cvt2byte(src, nl=True)

    wrt.s_lshl(off, mat_stride, 3) # 4 lines * 2 bytes per element
    wrt.s_sub(off, off, 'varlds_%ssize_per_wr' % mat, dtype='u32')
    wrt.for_loop(vw, partial(wrt.v_add, var_str(src, 'i'), off,
        var_str(src, 'i-1'), dtype='u32'), start=1)
    
    wrt.comments('global memory to lds address')
    wrt.s_mov(dest, 'varlds_%ssize_per_wave' % mat)
    wrt.s_mul(dest, 'sgprFetchSubGrpId', dest)
    wrt.s_add(dest, dest, 'var%s_lds_base_addr' % mat, dtype='i32')
    wrt.empty_line()


def fetch2lds(conf, wrt, mat, base, k=32, it=1):
    wrt.comments('fetch %s to lds' % mat)

    dest = 'vgprG2L' + mat
    off = 'vgprGlobalReadOfvar' + mat
    src_desc = 'sgprSrd' + mat
    vw = conf[mat + '_VW']
    wr_sz = 'varlds_%ssize_per_wr' % mat

    '''
    for i in range(it):
        set_lds_addr(fp, addr)
        for i in range(vw):
            offset = '%s * %d' % (wr_sz, i)
            buffer_load(fp, (dest, i), (off, i), (src_desc, 0, 3), lds=1, offset=offset)
        # update off to next iteration 
        for i in range(vw):
            v_add(fp, (off, i), 64, (off, i))
        #update lds addr
        s_add(fp, addr, addr, it_sz)
        wrt.empty_line()
    '''
    for i in range(it):
        wrt.set_lds_addr(base)
        func = partial(wrt.buffer_load, var_str(dest, 'i'), var_str(off, 'i'),
                src_desc, lds=1, offset='%s * i' % wr_sz)
        wrt.for_loop(vw, func)
        # update off to next iteration 
        func = partial(wrt.v_add, var_str(off, 'i'), 64, var_str(off, 'i'))
        wrt.for_loop(vw, func)
    wrt.empty_line()


def wait4fetch(wrt, wf_prio=0):
    vwA = conf['A_VW']
    vwB = conf['B_VW']

    # wait for A[0]
    wrt.waitcnt(2 * vwB + vwA, 'vm')
    if wf_prio > 0:
        wrt.setprio(wf_prio)
    wrt.barrier() 
    if wf_prio > 0:
        wrt.setprio(0)

    # wait for B[0]
    wrt.waitcnt(vwB + vwA, 'vm')
    if wf_prio > 0:
        wrt.setprio(wf_prio)
    wrt.barrier() 
    if wf_prio > 0:
        wrt.setprio(0)

    wrt.empty_line()


def do_fetch(conf, wrt):
    baseA1 = 'sgprLocalWriteAddrA'
    baseA2 = 'sgprLocalWriteAddrA+1'
    baseB1 = 'sgprLocalWriteAddrB'
    baseB2 = 'sgprLocalWriteAddrB+1'
    wrt.s_add(baseA2, baseA1, 'varlds_Asize_per_wg', dtype='u32')
    wrt.s_add(baseB2, baseB1, 'varlds_Bsize_per_wg', dtype='u32')
    prefetch = conf['prefetch']
    vwA = conf['A_VW']
    vwB = conf['B_VW']

    if prefetch:
        fetch2lds(conf, wrt, 'A', baseA1)
        fetch2lds(conf, wrt, 'B', baseB1)
        fetch2lds(conf, wrt, 'A', baseA2)
        fetch2lds(conf, wrt, 'B', baseB2)
        wait4fetch(wrt)

    lcnt = 'sgprLoopCounters'
    wrt.s_lshr(lcnt, 'sgprSizesSum', 5) # k=32
    wrt.s_sub(lcnt, 0, lcnt)
    if prefetch:
        wrt.s_add(lcnt, 2, lcnt, dtype='i32')
    wrt.empty_line()

    wrt.label('unroll_fetch')

    fetch2lds(conf, wrt, 'A', baseA1)
    fetch2lds(conf, wrt, 'B', baseB1)
    wait4fetch(wrt, 1)
    wrt.s_add(lcnt, 1, lcnt, dtype='u32')
    wrt.empty_line()

    fetch2lds(conf, wrt, 'A', baseA2)
    fetch2lds(conf, wrt, 'B', baseB2)
    wait4fetch(wrt, 1)
    wrt.s_add(lcnt, 1, lcnt, dtype='u32')
    wrt.empty_line()

    wrt.s_cmp('sgprLoopCounters', 0, dtype='i32')
    wrt.s_cbranch('unroll_fetch', eq=False)
    wrt.empty_line()

    wrt.label('finish_fetch')
    wrt.waitcnt(8, itype='vm')
    wrt.barrier()
    wrt.waitcnt(0, itype='vm')
    wrt.barrier()
    wrt.end_pgm()
    wrt.empty_line()


def def_fetch(conf, wrt):
    # load A/B address, stridesA/B, sgprTensor2dSizeA/B, size L
    load_karg(conf, wrt, 'sgprAddressA', 4)
    load_karg(conf, wrt, 'sgprStridesA', 4)
    load_karg(conf, wrt, 'sgprTensor2dSizeA', 4)
    load_karg(conf, wrt, 'sgprSizesSum')
    wrt.empty_line()

    # clamp lds size to 0x3000
    wrt.set_lds_addr(0x3000)

    get_thread_info(conf, wrt)

    create_branch(wrt, 'wave0_MAC', conf['vWaveID'], 1)

    # wait for load kern args
    wrt.waitcnt(0, 'lgkm')
    wrt.empty_line()

    # global address of A/B
    global_address_assignment(conf, wrt, 'A')
    global_address_assignment(conf, wrt, 'B')

    do_fetch(conf, wrt)


def listify(d):
    if isinstance(d, list): return d
    if isinstance(d, tuple): return list(d)
    return [d]


def local_address_assignment(conf, wrt, mat):
    wrt.comments('local address of %s' % mat)

    src = 'vgprLocalReadAddr' + mat
    src2 = 'vgprLocalReadAddr%s+1' % mat
    base = 'var%s_lds_base_addr' % mat
    step = 'varlds_%ssize_per_wg' % mat
    wave_sz = 'varlds_%ssize_per_wave' % mat
    k = conf['mfma']['k']

    # map thread to lds, map to 32 lanes
    wrt.v_mask('v1', conf['vWFTID'], '0x1f') # mask 32
    wrt.v_mul(src, 32, 'v1', dtype='u32', nl=True)

    # calc pad length
    wrt.v_lshr('v2', 2, 'v1') # a pad follow by 4 wr
    wrt.v_mul('v2', 'varlds_pad', 'v2', dtype='u32', nl=True)

    # 2 threads map to 1 lane, read k elements per lane
    wrt.v_lshr('v1', 5, conf['vWFTID'])
    wrt.v_lshl('v1', to_shift_bit(k / 2), 'v1')
    wrt.v_add(src, 'v1', src, dtype='u32')
    wrt.cvt2byte(src, nl=True)

    # add pad
    wrt.v_add(src, src, 'v2', dtype='u32', nl=True)

    # address subgrp of B, 1 wave of A can boardcast to all 4 waves of B
    if mat == 'B':
        wrt.s_mul('s84', 'sgprFetchSubGrpId', wave_sz)
        wrt.v_add(src, 's84', src, dtype='u32', nl=True)

    # add to base addr
    wrt.v_add(src, base, src, dtype='u32')
    wrt.v_add(src2, step, src, dtype='u32')
    wrt.empty_line()


def def_mac(conf, wrt):
    wrt.label('wave0_MAC')
    wrt.comments('hide all kern args load latency with ACC VGPR initialization')
    wrt.for_loop(32, partial(wrt.v_accvgpr, ('vgprAcc', 'i'), 0, 0, itype='write'))

    load_karg(conf, wrt, 'sgprTensor2dSizeC', 2)
    load_karg(conf, wrt, 'sgprAlpha', 4)
    load_karg(conf, wrt, 'sgprStridesD', 4)
    load_karg(conf, wrt, 'sgprAddressD', 4)
    wrt.empty_line()

    wrt.comments('Local Read Addresses')

    local_address_assignment(conf, wrt, 'A')
    local_address_assignment(conf, wrt, 'B')

    wrt.waitcnt(0, itype='lgkm', nl=True)


class GFX9Writer():
    def __init__(self, fp):
        self.fp = fp

    def write_line(self, s='', cmt='', tab=1, nl=False):
        pre_s = '  ' * tab
        if cmt != '':
            if not cmt.startswith('//'):
                cmt = '// ' + cmt
            cmt = '\t\t' + cmt
        self.fp.write(pre_s + s + cmt + '\n')
        if nl:
            self.fp.write('\n')

    def comments(self, s, bar=False, bar_len=40, tab=1, nl=False):
        pre_s = '  ' * tab
        if bar:
            bar_s = pre_s + '/' + '*' * bar_len + '/\n'
        s = pre_s + '/* ' + s + ' */\n' if bar else pre_s + '// ' + s + '\n'
        if bar:
            self.fp.write(bar_s)
        fp.write(s)
        if bar:
            self.fp.write(bar_s)
        if nl:
            self.fp.write('\n')

    def empty_line(self):
        self.fp.write('\n')

    def def_var(self, name, val, **kwargs):
        self.write_line('var ' + name + ' = ' + str(val), tab=0, **kwargs)

    def barrier(self, nl=False):
        self.write_line('s_barrier', tab=1, nl=nl)

    def setprio(self, prio, nl=False):
        self.write_line('s_setprio %d' % prio, tab=1, nl=nl)

    def waitcnt(self, cnt, itype=None, **kwargs):
        s = '%scnt(%d)' % (itype, cnt) if itype else str(cnt)
        self.write_line('s_waitcnt\t%s' % s, **kwargs)

    def sopc_instr(self, src0, src1, op, dtype, **kwargs):
        src0, src1 = reg_str(src0), reg_str(src1)
        self.write_line('s_cmp_%s_%s\t%s, %s' % (op, dtype, src0, src1), **kwargs)

    def sop1_sopk_instr(self, cmd, dtype, dest, src, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('s_%s_%s\t%s, %s' % (cmd, dtype, dest, src), **kwargs)

    def sop2_instr(self, cmd, dtype, dest, src0, src1, **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('s_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
            src1), **kwargs)

    def s_mov(self, dest, src, dtype='b32', **kwargs):
        self.sop1_sopk_instr('mov', dtype, dest, src, **kwargs)

    def s_sub(self, dest, src0, src1, dtype='i32', **kwargs):
        self.sop2_instr('sub', dtype, dest, src0, src1, **kwargs)

    def s_mul(self, dest, src0, src1, hi=False, dtype='i32', **kwargs):
        self.sop2_instr('mul_hi' if hi else 'mul', dtype, dest, src0, src1, **kwargs)

    def s_lsh(self, dest, src0, src1, ldir=True, dtype='b32', **kwargs):
        self.sop2_instr('lshl' if ldir else 'lshr', dtype, dest, src0, src1, **kwargs)

    def s_lshl(self, dest, src0, src1, dtype='b32', **kwargs):
        self.s_lsh(dest, src0, src1, dtype=dtype, ldir=True, **kwargs)

    def s_lshr(self, dest, src0, src1, dtype='b32', **kwargs):
        self.s_lsh(dest, src0, src1, dtype=dtype, ldir=False, **kwargs)

    def s_add(self, dest, src0, src1, carry_out=False, dtype='i32', **kwargs):
        self.sop2_instr('addc' if carry_out else 'add', dtype, dest, src0, src1, **kwargs)

    def s_cmp(self, src0, src1, op='eq', dtype='u32', **kwargs):
        src0, src1 = reg_str(src0), reg_str(src1)
        self.sopc_instr(src0, src1, op, dtype, **kwargs)

    def s_cbranch(self, label, eq=True, **kwargs):
        self.write_line('s_cbranch_scc%d\t%s' % (1 if eq else 0, label), **kwargs)

    def s_load(self, sgpr, src, off, dw=1, **kwargs):
        s = 's_load_dword%s %s, %s, 0x%x' % ('x' + str(dw) if dw > 1 else '',
                reg_str(sgpr, end_off=(dw - 1)),
                reg_str(src, end_off=1), off)
        self.write_line(s, **kwargs)

    def vop1_instr(self, cmd, dtype, dest, src, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('v_%s_%s\t%s, %s' % (cmd, dtype, dest, src), **kwargs)

    def vop2_instr(self, cmd, dtype, dest, src0, src1, **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('v_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
            src1), **kwargs)

    def v_lsh(self, dest, src0, src1, dtype, ldir, **kwargs):
        self.vop2_instr('lshlrev' if ldir else 'lshrrev', dtype, dest, src0, src1, **kwargs)

    def v_mask(self, dest, src, subgrp_sz, dtype='b32', **kwargs):
        self.vop2_instr('and', dtype, dest, src, subgrp_sz, **kwargs)

    def v_lshl(self, dest, src0, src1, dtype='b32', **kwargs):
        self.v_lsh(dest, src0, src1, dtype=dtype, ldir=True, **kwargs)

    def v_lshr(self, dest, src0, src1, dtype='b32', **kwargs):
        self.v_lsh(dest, src0, src1, dtype=dtype, ldir=False, **kwargs)

    def v_mov(self, dest, src, dtype='b32', **kwargs):
        self.vop1_instr('mov', dtype, dest, src, **kwargs)

    def v_add(self, dest, src0, src1, carry_out=False, dtype='i32', **kwargs):
        if carry_out == False:
            self.vop2_instr('add', dtype, dest, src0, src1, **kwargs)
        else:
            dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
            self.write_line('v_add_co_%s\t%s, vcc, %s, %s' % (dtype, dest, src0,
                src1), **kwargs)

    def v_mul(self, dest, src0, src1, dtype='i32', **kwargs):
        self.vop2_instr('mul_lo', dtype, dest, src0, src1, **kwargs)

    def set_lds_addr(self, addr, **kwargs):
        self.s_mov('m0', addr, tab=1, nl=True, **kwargs)

    def read_hwreg(self, dest, src, **kwargs):
        self.sop1_sopk_instr('getreg', 'b32', dest, 'hwreg(' + src + ')', **kwargs)

    def vgpr2sgpr(self, dest, src, **kwargs):
        self.vop1_instr('readfirstlane', 'b32', dest, src, **kwargs)

    def label(self, s, **kwargs):
        self.write_line(s + ":", tab=0, **kwargs)

    def buffer_load(self, dest, off, src_desc, dw=1, lds=0, offset=None, **kwargs):
        dest, off, src_desc = reg_str(dest), reg_str(off), reg_str(src_desc, end_off=3)
        s = 'buffer_load_dword%s %s, %s, %s, %s' % ('x' + str(dw) if dw > 1 else '',
                dest, off, src_desc, '0 offen:1 lds:%d offset:%s' % (lds, offset))
        self.write_line(s, **kwargs)

    def cmp_jmp(self, label, var, val, eq=True, **kwargs):
        self.s_cmp(var, val, **kwargs)
        self.s_cbranch(label, eq, **kwargs)

    def end_pgm(self, **kwargs):
        self.write_line('s_endpgm', **kwargs)

    def cvt2byte(self, var, **kwargs):
        self.v_lshl(var, 1, var, **kwargs)

    def for_loop(self, loops, func_list, start=0, idxs='i,j,k,l,m,n', tab=1, nl=True):
        loops, func_list = listify(loops), listify(func_list)
        idxs = idxs.split(',')
        for i, k in enumerate(loops):
            idx = idxs[i]
            self.write_line('for var %s = %d; %s < %d; %s++' % (idx, start, idx, k, idx), tab=tab)
            tab += 1
        for o in func_list: o(tab=tab+1)
        for i in range(len(loops)):
            tab -= 1
            if tab <= 0: break
            self.write_line('end', tab=tab)
        if nl: self.empty_line()

    def v_accvgpr(self, dest, src0, src1, itype='read', **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('v_accvgpr_%s\t%s, %s, %s' % (itype, dest, src0, src1), **kwargs)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.description = "Replacement kernel generator"
    parser.add_argument("-f", "--config", type=str, help='specify config file path')
    parser.add_argument("-o", "--output", type=str, help='specify output file path')
    args = parser.parse_args()

    if not args.config:
        print('No config file specified, please use "--help" for more details.')
        exit(-1)

    if not args.output:
        out_fpath = Path(args.config).stem + '.sp3'

    conf = json.load(open(args.config, 'r'))
    with open(out_fpath, 'w') as fp:
        writer = GFX9Writer(fp)
        def_vars(conf, writer)
        def_header(conf, writer)
        def_fetch(conf, writer)
        def_mac(conf, writer)
        def_footer(conf, writer)

    print("[Output]: %s" % out_fpath)

