#!/usr/bin/env python3


import argparse
import json
import os
import pdb
#import numpy as np
#import pandas as pd
from pathlib import Path
from functools import partial


def def_vars(conf, wrt):
    # sgpr & vgpr variables
    for k in ['sregs', 'vregs']:
        wrt.comments('Define %s variables' % k)
        for k, v in conf[k].items():
            wrt.def_var(k, v)
        wrt.empty_line()

    wrt.def_var('BufferLimit', 0x80000000, cmt='2GB limit - set offsets to -1 to exceed this and clamp')
    wrt.def_var('Srd127_96', 0x20000, cmt='Bits 127:96 of SRD.  Set DataFormat = 32 bit')
    wrt.def_var('roundMaskVal', 0xffff0000, nl=True)

    # lds variables
    pad = 8
    mt_h = conf['mt']['h']
    mt_w = conf['mt']['w']
    simd = conf['mfma']['simd']
    a_per_wr = 256 + pad
    lvca = int(32 / (conf['glvw'] * 2))
    rows_per_wave = int(mt_h / simd)
    a_vw = int(rows_per_wave / (64 / lvca))
    a_per_wave = a_per_wr * a_vw
    a_per_wg = a_per_wave * simd
    b_per_wr = 256 + pad
    lvcb = int(32 / (conf['glvw'] * 2))
    cols_per_wave = int(mt_w / simd)
    b_vw = int(cols_per_wave / (64 / lvcb))
    b_per_wave = b_per_wr * b_vw
    b_per_wg = b_per_wave * simd

    wrt.comments("Define lds vars")
    wrt.def_var('varlds_pad', pad)
    wrt.def_var('varlds_Asize_per_wr', a_per_wr, cmt='256 + varlds_pad')
    wrt.def_var('varlds_Asize_per_wave', 'varlds_Asize_per_wr * %d' % a_vw, cmt='vw == %d' % a_vw)
    wrt.def_var('varlds_Asize_per_wg', 'varlds_Asize_per_wave * %d' % simd)
    wrt.empty_line()
    wrt.def_var('varlds_Bsize_per_wr', b_per_wr, cmt='256 + varlds_pad')
    wrt.def_var('varlds_Bsize_per_wave', 'varlds_Bsize_per_wr * %d' % b_vw, cmt='vw == %d' % b_vw)
    wrt.def_var('varlds_Bsize_per_wg', 'varlds_Bsize_per_wave * %d' % simd)
    wrt.empty_line()
    wrt.def_var('varA_lds_base_addr', 0)
    wrt.def_var('varB_lds_base_addr', 'varA_lds_base_addr + varlds_Asize_per_wg * 2')
    wrt.empty_line()

    conf['lvca'] = lvca
    conf['lvcb'] = lvcb
    conf['A_VW'] = a_vw
    conf['B_VW'] = b_vw


def def_header(conf, wrt):
    wrt.write_line('shader main', tab=0)
    wrt.write_line('type(CS)')
    wrt.write_line('user_sgpr_count(14)')
    wrt.write_line('tgid_x_en(1)')
    wrt.write_line('tgid_y_en(1)')
    wrt.write_line('tgid_z_en(1)')
    wrt.write_line('tidig_comp_cnt(2)')
    wrt.empty_line()


def def_footer(conf, wrt):
    wrt.label('finish')
    wrt.waitcnt(0)
    wrt.end_pgm()
    wrt.empty_line()
    wrt.write_line('end', tab=0)
    wrt.empty_line()


def reg_str(s, start_off=0, end_off=0):
    if isinstance(s, str) and (s.startswith('v[') or s.startswith('s[')):
        return s
    if isinstance(s, int) or (isinstance(s, str) and s[0].isdigit()):
        return s
    if isinstance(s, tuple):
        s, *off = s
        start_off = off[0]
        if len(off) > 1: end_off = off[1]
    if not s.startswith('vgpr') and not s.startswith('sgpr'):
        return s
    dtype = 'v' if s.startswith('vgpr') else 's'
    if end_off != 0: 
        s = '%s+%s:%s+%s' % (s, start_off, s, end_off)
    elif start_off != 0:
        s = '%s+%s' % (s, start_off)
    return dtype + '[' + s + ']'


# load kernel args to sgpr
def load_karg(conf, wrt, var, dw=1):
    wrt.s_load(var, 'sgprKernArgAddress', conf['kargs'][var], dw=dw)


def var_str(*s):
    return '+'.join(str(o) for o in s)


def get_thread_info(conf, wrt):
    #vgprSerial    holds threadIdx
    #vgprSerial+1  holds WaveFrontId (0-63)
    #vgprSerial+2  holds threadIdy  (simd= 0,1,2,3)
    #vgprSerial+3  holds threadIdZ  (wave0 =0 wave1 = 1)
    tid = 'vgprSerial'
    wf_tid = var_str(tid, 1)
    simd_id = var_str(tid, 2)
    wave_id = var_str(tid, 3)

    wrt.v_mov(tid, 'v0')
    wrt.v_mask(wf_tid, tid, 64) # wave front id

    #HW_ID_REG
    #bit[0-3] #waveId
    #bit[5-4] #simdId
    #bit[11-8] #CuId
    hwid = 'sgprHWID'
    wrt.read_hwreg(hwid, 'HW_REG_HW_ID')
    wrt.v_mask('v4', '0x30', hwid)  # simd
    wrt.v_lshr(simd_id, 4, 'v4')
    wrt.v_mask(wave_id, '0xf', hwid) # waveid
    conf['vTID'] = tid
    conf['vWFTID'] = wf_tid
    conf['vSIMDID'] = simd_id
    conf['vWaveID'] = wave_id
    wrt.empty_line()


def create_branch(wrt, label, var, val, eq=False):
    svar = 'sgprHWID+1'
    wrt.vgpr2sgpr(svar, var)
    wrt.cmp_jmp(label, svar, val, eq=False)
    wrt.empty_line()


def to_shift_bit(val):
    b, s = 0, 1
    while s < val:
        s *= 2
        b += 1
    return b


def mat_idx(mat):
    if mat == 'A': return 0
    elif mat == 'B': return 1


class Data():
    def __init__(self, conf, wrt, mat):
        self.conf, self.wrt, self.mat = conf, wrt, mat
        self.global_read_dest_addr = 'vgprG2L' + mat
        self.global_read_src_addr = 'vgprGlobalReadOfvar' + mat
        self.global_read_offset = 'sgprScalarGlobalReadOffset' + mat
        self.local_write_addr = ('sgprLocalWriteAddr' + mat, 'sgprLocalWriteAddr%s+1' % mat)
        self.local_read_addr = 'vgprLocalReadAddr' + mat
        self.src = 'sgprAddress' + mat
        self.src_desc = 'sgprSrd' + mat
        self.simd_id = 'sgprFetchSubGrpId'
        self.stride = ('sgprStrides' + mat, 'sgprStrides%s+1' % mat)
        self.vw = conf[mat + '_VW']
        self.wg = ('sgprWorkGroup0', 'sgprWorkGroup1', 'sgprWorkGroup2')
        self.sz_per_wr = 'varlds_%ssize_per_wr' % mat
        self.sz_per_wave = 'varlds_%ssize_per_wave' % mat
        self.sz_per_wg = 'varlds_%ssize_per_wg' % mat
        self.lds_base_addr = 'var%s_lds_base_addr' % mat
        self.vmcnt = 0

    def global_address(self):
        self.wrt.comments('Global Address Assignment of %s' % self.mat, bar=True, nl=True)

        self.wrt.comments('resource descriptor')
        self.wrt.s_mov(self.src_desc, self.src, cmt='sgpr[0-1] - base address')
        self.wrt.s_mov((self.src_desc, 1), (self.src, 1))
        self.wrt.s_mov((self.src_desc, 2), 'BufferLimit', cmt='sgpr[2]   - limit')
        self.wrt.s_mov((self.src_desc, 3), 'Srd127_96', cmt='sgpr[3]   - attributes')
        self.wrt.empty_line()

        # start address of workgroup
        wg_addr, wave_addr = 's84', 's85'
        mt = self.conf['mt']['h'] if self.mat == 'A' else self.conf['mt']['w']
        wg = self.wg[0] if self.mat == 'A' else self.wg[1]
        lines_per_wave = mt // 4
        lvca = self.conf['lvca']
        tid = self.conf['vWFTID']

        self.wrt.comments('%s: address of workgroup' % wg_addr)
        self.wrt.s_mul(wg_addr, self.stride[0], mt)
        self.wrt.s_mul(wg_addr, wg, wg_addr)

        self.wrt.comments('%s: address of wave' % wave_addr)
        self.wrt.s_mul(wave_addr, self.stride[0], lines_per_wave)
        self.wrt.s_mul(wave_addr, self.simd_id, wave_addr)
        self.wrt.s_add(wave_addr, wg_addr, wave_addr)

        lane_id, tile_addr, lane_addr = 'v0', 'v1', 'v4'

        self.wrt.comments('%s: address of lane' % lane_addr)
        self.wrt.comments('LVCA=%d' % lvca)
        self.wrt.v_lshr(lane_id, to_shift_bit(lvca), tid)
        self.wrt.v_mul(lane_addr, self.stride[0], lane_id, dtype='u32')

        self.wrt.comments('%s: address of tile' % tile_addr)
        self.wrt.v_mask(tile_addr, lvca - 1, tid)
        self.wrt.v_lshl(tile_addr, 1, tile_addr, cmt='1 dword == 2 elements')

        self.wrt.comments('%s: address of global address' % self.global_read_src_addr)
        self.wrt.v_add(self.global_read_src_addr, lane_addr, tile_addr, dtype='u32', carry_out=True)
        self.wrt.v_add(self.global_read_src_addr, self.global_read_src_addr, wave_addr, dtype='u32')
        self.wrt.cvt2byte(self.global_read_src_addr)

        self.wrt.empty_line()

        self.wrt.comments('%s: offset of vector width' % self.global_read_offset)
        self.wrt.comments('vw=-1')
        # 4 lanes * 2 bytes per element, next read from 5th lane
        self.wrt.s_lshl(self.global_read_offset, self.stride[0], 3) 
        self.wrt.s_sub(self.global_read_offset, self.global_read_offset, self.sz_per_wr, dtype='u32')
        for i in range(1, self.vw):
            self.wrt.v_add((self.global_read_src_addr, i), self.global_read_offset,
                    (self.global_read_src_addr, i - 1))
        self.wrt.empty_line()

        self.wrt.comments('set local write address')
        self.wrt.s_mov(self.local_write_addr[0], self.sz_per_wave)
        self.wrt.s_mul(self.local_write_addr[0], self.simd_id, self.local_write_addr[0])
        self.wrt.s_add(self.local_write_addr[0], self.local_write_addr[0], self.lds_base_addr)
        self.wrt.s_add(self.local_write_addr[1], self.local_write_addr[0], self.sz_per_wave)
        self.lds_ptr = self.local_write_addr[0]
        self.wrt.empty_line()

    def global_fetch(self):
        self.wrt.comments('fetch %s to lds' % self.mat)
        self.update_lds_ptr()
        for i in range(self.vw):
            offset = '%s * %d' % (self.sz_per_wr, i)
            self.wrt.buffer_load((self.global_read_dest_addr, i), (self.global_read_src_addr, i),
                    (self.src_desc, 0, 3), lds=1, offset=offset)
        self.vmcnt += self.vw
        self.wrt.empty_line()

    def update_lds_ptr(self):
        self.wrt.comments('set lds base address to %s' % self.lds_ptr)
        self.wrt.set_lds_addr(self.lds_ptr)
        self.lds_ptr = self.local_write_addr[1] if self.lds_ptr == self.local_write_addr[0] else self.local_write_addr[0]

    def global_inc_fetch_addr(self, prio=0):
        self.wrt.comments('increment global address of %s to next iteration' % self.mat)
        # update to next iteration 
        if prio:
            self.wrt.setprio(prio)
        for i in range(self.vw):
            self.wrt.v_add((self.global_read_src_addr, i), 64, (self.global_read_src_addr, i))
        if prio:
            self.wrt.setprio(0)
        self.wrt.empty_line()

    def wait4fetch(self):
        self.wrt.waitcnt(20 if self.mat == 'A' else 12, 'vm')
        self.wrt.barrier(cmt='wait for LDS %s' % self.mat) 
        self.wrt.empty_line()

    def local_address(self):
        # all wave load the same A, 4 waves load 4 Bs
        # map threads to 32 lanes on LDS
        self.wrt.comments('Local Address Assignment of %s' % self.mat, bar=True, nl=True)
        self.wrt.comments('%s: address of lane' % self.local_read_addr)
        tid = 'v1'
        self.wrt.v_mask(tid, self.conf['vWFTID'], '0x1f') # tid_wavefront mask 32, 2 threads per lane
        self.wrt.v_mul(self.local_read_addr, 32, tid, dtype='u32') # map to column
        self.wrt.empty_line()

        # calc pad length
        pad_len, pad = 'v2', 'varlds_pad'
        self.wrt.comments('%s: padding length' % pad_len)
        self.wrt.v_lshr(pad_len, 2, tid) # a pad follow by 4 wr
        self.wrt.v_mul(pad_len, pad, pad_len, dtype='u32')
        self.wrt.empty_line()

        # 2 threads map to 1 lane, read threadtile elements per thread
        tid_lane = 'v1'
        self.wrt.comments('%s: address of threadtile' % self.local_read_addr)
        self.wrt.v_lshr(tid_lane, 5, conf['vWFTID'])
        self.wrt.v_lshl(tid_lane, to_shift_bit(conf['thread_tile']), tid_lane)
        self.wrt.v_add(self.local_read_addr, tid_lane, self.local_read_addr, dtype='u32')
        self.wrt.cvt2byte(self.local_read_addr)
        self.wrt.empty_line()

        # add pad
        self.wrt.comments('add padding length')
        self.wrt.v_add(self.local_read_addr, self.local_read_addr, pad_len, dtype='u32')
        self.wrt.empty_line()

        # address subgrp of B, 1 wave of A can boardcast to all 4 waves of B
        if self.mat == 'B':
            wave_addr = 's84'
            self.wrt.comments('4 waves load 4 B, %s: address of wave' % wave_addr)
            self.wrt.s_mul(wave_addr, self.simd_id, self.sz_per_wave)
            self.wrt.v_add(self.local_read_addr, wave_addr, self.local_read_addr, dtype='u32')
            self.wrt.empty_line()

        # add title offset to base addr
        self.wrt.v_add(self.local_read_addr, self.lds_base_addr, self.local_read_addr, dtype='u32')
        self.wrt.v_add((self.local_read_addr, 1), self.sz_per_wg, self.local_read_addr, dtype='u32')
        self.wrt.empty_line()


def unroll_fetch(wrt, mat_a, mat_b):
    wrt.barrier(cmt='wait for LDS A[0] & B[0]')
    wrt.empty_line()

    wrt.comments('unroll 0')
    mat_a.global_fetch()
    mat_b.global_fetch()
    mat_a.wait4fetch()
    mat_a.global_inc_fetch_addr(prio=1)
    mat_b.wait4fetch()
    mat_b.global_inc_fetch_addr(prio=1)

    wrt.barrier(cmt='wait for LDS A[1] & B[1]')
    wrt.empty_line()

    wrt.comments('unroll 1')
    mat_a.global_fetch()
    mat_b.global_fetch()
    mat_a.wait4fetch()
    mat_a.global_inc_fetch_addr(prio=1)
    mat_b.wait4fetch()
    mat_b.global_inc_fetch_addr(prio=1)
    wrt.empty_line()


def def_fetch(conf, wrt, mat_a, mat_b):
    # load A/B address, stridesA/B, sgprTensor2dSizeA/B, size L
    load_karg(conf, wrt, 'sgprAddressA', 4)
    load_karg(conf, wrt, 'sgprStridesA', 4)
    load_karg(conf, wrt, 'sgprTensor2dSizeA', 4)
    load_karg(conf, wrt, 'sgprSizesSum')
    wrt.empty_line()

    # clamp lds size to 0x3000
    wrt.set_lds_addr(0x3000)

    get_thread_info(conf, wrt)

    create_branch(wrt, 'wave0_MAC', conf['vWaveID'], 1)

    # wait for load kern args
    wrt.waitcnt(0, 'lgkm')
    wrt.empty_line()

    mat_a.global_address()
    mat_b.global_address()

    wrt.comments('Global Fetch A/B', bar=True, nl=True)
    wrt.barrier(cmt='sync up for global fetch')
    wrt.empty_line()

    # A[0], B[0]
    mat_a.global_fetch()
    mat_b.global_fetch()
    mat_a.global_inc_fetch_addr()
    mat_b.global_inc_fetch_addr()

    # A[1], B[1]
    mat_a.global_fetch()
    mat_b.global_fetch()
    mat_a.global_inc_fetch_addr()
    mat_b.global_inc_fetch_addr()

    mat_a.wait4fetch()
    mat_b.wait4fetch()

    wrt.unroll('unroll_fetch', partial(unroll_fetch, wrt, mat_a, mat_b), end=-2, step=2)

    # finish fetch
    wrt.waitcnt(8, 'vm')
    wrt.barrier()
    wrt.waitcnt(0, 'vm')
    wrt.barrier()
    wrt.empty_line()
    wrt.end_pgm()
    wrt.empty_line()
    wrt.empty_line()


def listify(d):
    if isinstance(d, list): return d
    if isinstance(d, tuple): return list(d)
    return [d]


def local_address_assignment(conf, wrt, mat):
    wrt.comments('local address of %s' % mat)

    src = 'vgprLocalReadAddr' + mat
    src2 = 'vgprLocalReadAddr%s+1' % mat
    base = 'var%s_lds_base_addr' % mat
    step = 'varlds_%ssize_per_wg' % mat
    wave_sz = 'varlds_%ssize_per_wave' % mat
    k = conf['mfma']['k']

    # all wave load the same A, 4 wave load 4 B
    # map thread to lds, map to 32 lanes
    wrt.v_mask('v1', conf['vWFTID'], '0x1f') # mask 32
    wrt.v_mul(src, 32, 'v1', dtype='u32', nl=True)

    # calc pad length
    wrt.v_lshr('v2', 2, 'v1') # a pad follow by 4 wr
    wrt.v_mul('v2', 'varlds_pad', 'v2', dtype='u32', nl=True)

    # 2 threads map to 1 lane, read k elements per lane
    wrt.v_lshr('v1', 5, conf['vWFTID'])
    wrt.v_lshl('v1', to_shift_bit(k / 2), 'v1')
    wrt.v_add(src, 'v1', src, dtype='u32')
    wrt.cvt2byte(src, nl=True)

    # add pad
    wrt.v_add(src, src, 'v2', dtype='u32', nl=True)

    # address subgrp of B, 1 wave of A can boardcast to all 4 waves of B
    if mat == 'B':
        wrt.s_mul('s84', 'sgprFetchSubGrpId', wave_sz)
        wrt.v_add(src, 's84', src, dtype='u32', nl=True)

    # add to base addr
    wrt.v_add(src, base, src, dtype='u32')
    wrt.v_add(src2, step, src, dtype='u32')
    wrt.empty_line()


def calc_global_addressC(conf, wrt):
    wrt.comments('Global Address C calculation')

    set_addr_desc(wrt, 'C')
    set_addr_desc(wrt, 'D')

    mt = (conf['mt']['h'], conf['mt']['w'])
    wg = ('sgprWorkGroup0', 'sgprWorkGroup1', 'sgprWorkGroup2')
    strideC = ('sgprStridesC', 'sgprStridesC+1')
    srdC = ('sgprSrdC', 'sgprSrdC+1')
    srdD = ('sgprSrdD', 'sgprSrdD+1')
    src = 'vgprGlobalWriteOfvarC'

    # calc MT offset on y dim
    wrt.s_mul('s86', mt[1], wg[1])
    wrt.s_mul('s85', 's86', strideC[0], hi=True, dtype='u32')
    wrt.s_mul('s84', 's86', strideC[0])
    wrt.s_lshl('s[84:85]', 's[84:85]', 1, dtype='b64')

    # add MT offset (y dim)
    wrt.s_add(srdC[0], srdC[0], 's84', dtype='u32')
    wrt.s_add(srdC[1], srdC[1], 's85', carry_out=True, dtype='u32')
    wrt.s_add(srdD[0], srdD[0], 's84', dtype='u32')
    wrt.s_add(srdD[1], srdD[1], 's85', carry_out=True, dtype='u32', nl=True)
    
    # calc MT offset on z dim 
    wrt.s_mul('s85', wg[2], strideC[1], hi=True, dtype='u32')
    wrt.s_mul('s84', wg[2], strideC[1])
    wrt.s_lshl('s[84:85]', 's[84:85]', 1, dtype='b64')

    # add MT offset (z dim)
    wrt.s_add(srdC[0], srdC[0], 's84', dtype='u32')
    wrt.s_add(srdC[1], srdC[1], 's85', carry_out=True, dtype='u32')
    wrt.s_add(srdD[0], srdD[0], 's84', dtype='u32')
    wrt.s_add(srdD[1], srdD[1], 's85', carry_out=True, dtype='u32', nl=True)

    # use z dim to re-map threadIdx using for calculating waveId start off set for MAC wves to store 'C'
    wrt.v_lshl(conf['vTID'], 6, conf['vWaveID'], cmt='threadIdx = simdId<<6')
    wrt.v_add(conf['vTID'], conf['vWFTID'], conf['vTID'], dtype='u32', cmt='threadIdx = threadIdx + 0-63')
    wrt.v_mul('v4', 32, conf['vWFTID'], dtype='u32', cmt='scale by sub-tile-size 32 (B-tile/128)')
    wrt.v_mul('v3', 'v4', strideC[0], dtype='u32', cmt='wavestart vgpr')
    wrt.v_mask('v4', '0x1f', conf['vTID'], cmt='vectorStaticDiv vgprTmp = vgprSerial % 31')
    wrt.v_mul('v5', 'v4', strideC[0], dtype='u32', cmt='rowstart VGPR')
    wrt.v_mask('v4', '0x3f', conf['vTID'], cmt='vectorStaticDiv vgprTmp = vgprSerial % 63')
    wrt.v_lshr('v6', 5, 'v4', cmt='vectorStaticDiv vgprTmp = vgprSerial / 32')
    wrt.v_lshr('v6', 2, 'v6', cmt='*4')
    wrt.v_add('vgprTmp+1', 'v3', 'v5', dtype='u32')
    wrt.empty_line()

    # calc MT offset on x dim 
    wrt.s_mul('s84', mt[0], wg[0])

    # add x dim MT offset to src variable
    wrt.v_add('vgprTmp', 's84', 'v6', carry_out=True, dtype='u32')
    wrt.v_add_lshl(src, 'vgprTmp', 'vgprTmp+1', 1, cmt='base_addr = wave_start+row_start scaled by BPE', nl=True)
    wrt.empty_line()


def matmul(conf, wrt):
    # mfma k == 8, 2 threads per lane, 1 thread read 4 elements
    # wait for LDS ready
    wrt.barrier(cmt='wait for LDS A ready')

    next_grp = 'varlds_Asize_per_wr * 8' # *2 == scale bpe

    # read A from LDS
    k = conf['mfma']['k']
    wrt.setprio(1)
    for i, j in enumerate(range(int(conf['k'] / k))):
        j *= 2
        wrt.ds_read(('vgprValuA_X0_I0', j, j + 1), 'vgprLocalReadAddrA', i * 16)
        wrt.ds_read(('vgprValuA_X0_I0+%d' % k, j, j + 1), 'vgprLocalReadAddrA', next_grp + ' + ' + str(i * 16))
    wrt.setprio(0)
    wrt.empty_line()

    wrt.waitcnt(0, 'lgkm')
    wrt.barrier(cmt='wait for LDS B ready')

    wrt.setprio(1)
    for i, j in enumerate(range(int(conf['k'] / k))):
        j *= 2
        wrt.ds_read(('vgprValuB_X0_I0', j, j + 1), 'vgprLocalReadAddrB', i * 16)
        wrt.waitcnt(0, 'lgkm')
        wrt.v_mfma('vgprAcc', ('vgprValuA_X0_I0', j), ('vgprValuB_X0_I0', j), 'vgprAcc')
        wrt.ds_read(('vgprValuB_X0_I0', j + 2, j + 3), 'vgprLocalReadAddrB', i * 16)
        wrt.waitcnt(0, 'lgkm')
        wrt.v_mfma('vgprAcc+16', ('vgprValuA_X0_I0+%d' % k, j), ('vgprValuB_X0_I0', j), 'vgprAcc+16')
    wrt.empty_line()
    wrt.setprio(0)


def def_mac(conf, wrt, mat_a, mat_b):
    wrt.label('wave0_MAC')
    wrt.comments('hide all kern args load latency with ACC VGPR initialization')
    wrt.for_loop(32, partial(wrt.v_accvgpr, ('vgprAcc', 'i'), 0, 0, itype='write'))

    load_karg(conf, wrt, 'sgprTensor2dSizeC', 2)
    load_karg(conf, wrt, 'sgprAlpha', 4)
    load_karg(conf, wrt, 'sgprStridesD', 4)
    load_karg(conf, wrt, 'sgprAddressD', 4)
    wrt.empty_line()

    mat_a.local_address()
    mat_b.local_address()

    # wait for kern vars load
    wrt.waitcnt(0, itype='lgkm', nl=True)

    #calc_global_addressC(conf, wrt)

    #matmul(conf, wrt)


class GFX9Writer():
    def __init__(self, fp):
        self.fp = fp

    def write_line(self, s='', cmt='', tab=1, nl=False):
        pre_s = '  ' * tab
        if cmt != '':
            if not cmt.startswith('//'):
                cmt = '// ' + cmt
            cmt = '\t\t' + cmt
        self.fp.write(pre_s + s + cmt + '\n')
        if nl:
            self.fp.write('\n')

    def comments(self, s, bar=False, bar_len=40, tab=1, nl=False):
        pre_s = '  ' * tab
        if bar:
            bar_s = pre_s + '/' + '*' * bar_len + '/\n'
        s = pre_s + '/* ' + s + ' */\n' if bar else pre_s + '// ' + s + '\n'
        if bar:
            self.fp.write(bar_s)
        fp.write(s)
        if bar:
            self.fp.write(bar_s)
        if nl:
            self.fp.write('\n')

    def empty_line(self):
        self.fp.write('\n')

    def def_var(self, name, val, **kwargs):
        self.write_line('var ' + name + ' = ' + str(val), tab=0, **kwargs)

    def barrier(self, **kwargs):
        self.write_line('s_barrier', tab=1, **kwargs)

    def setprio(self, prio, nl=False):
        self.write_line('s_setprio %d' % prio, tab=1, nl=nl)

    def waitcnt(self, cnt, itype=None, **kwargs):
        s = '%scnt(%d)' % (itype, cnt) if itype else str(cnt)
        self.write_line('s_waitcnt\t%s' % s, **kwargs)

    def sopc_instr(self, src0, src1, op, dtype, **kwargs):
        src0, src1 = reg_str(src0), reg_str(src1)
        self.write_line('s_cmp_%s_%s\t%s, %s' % (op, dtype, src0, src1), **kwargs)

    def sop1_sopk_instr(self, cmd, dtype, dest, src, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('s_%s_%s\t%s, %s' % (cmd, dtype, dest, src), **kwargs)

    def sop2_instr(self, cmd, dtype, dest, src0, src1, **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('s_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
            src1), **kwargs)

    def s_mov(self, dest, src, dtype='b32', **kwargs):
        self.sop1_sopk_instr('mov', dtype, dest, src, **kwargs)

    def s_sub(self, dest, src0, src1, dtype='i32', **kwargs):
        self.sop2_instr('sub', dtype, dest, src0, src1, **kwargs)

    def s_mul(self, dest, src0, src1, hi=False, dtype='i32', **kwargs):
        self.sop2_instr('mul_hi' if hi else 'mul', dtype, dest, src0, src1, **kwargs)

    def s_lsh(self, dest, src0, src1, ldir=True, dtype='b32', **kwargs):
        self.sop2_instr('lshl' if ldir else 'lshr', dtype, dest, src0, src1, **kwargs)

    def s_lshl(self, dest, src0, src1, dtype='b32', **kwargs):
        self.s_lsh(dest, src0, src1, dtype=dtype, ldir=True, **kwargs)

    def s_lshr(self, dest, src0, src1, dtype='b32', **kwargs):
        self.s_lsh(dest, src0, src1, dtype=dtype, ldir=False, **kwargs)

    def s_add(self, dest, src0, src1, carry_out=False, dtype='i32', **kwargs):
        self.sop2_instr('addc' if carry_out else 'add', dtype, dest, src0, src1, **kwargs)

    def s_cmp(self, src0, src1, op='eq', dtype='u32', **kwargs):
        src0, src1 = reg_str(src0), reg_str(src1)
        self.sopc_instr(src0, src1, op, dtype, **kwargs)

    def s_cbranch(self, label, eq=True, **kwargs):
        self.write_line('s_cbranch_scc%d\t%s' % (1 if eq else 0, label), **kwargs)

    def s_load(self, sgpr, src, off, dw=1, **kwargs):
        s = 's_load_dword%s %s, %s, 0x%x' % ('x' + str(dw) if dw > 1 else '',
                reg_str(sgpr, end_off=(dw - 1)),
                reg_str(src, end_off=1), off)
        self.write_line(s, **kwargs)

    def vop1_instr(self, cmd, dtype, dest, src, **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('v_%s_%s\t%s, %s' % (cmd, dtype, dest, src), **kwargs)

    def vop2_instr(self, cmd, dtype, dest, src0, src1, **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('v_%s_%s\t%s, %s, %s' % (cmd, dtype, dest, src0,
            src1), **kwargs)

    def vop3_instr(self, cmd, dtype, dest, src0, src1, src2, **kwargs):
        dest, src0, src1, src2 = reg_str(dest), reg_str(src0), reg_str(src1), reg_str(src2)
        self.write_line('v_%s_%s\t%s, %s, %s, %s' % (cmd, dtype, dest, src0,
            src1, src2), **kwargs)

    def v_lsh(self, dest, src0, src1, dtype, ldir, **kwargs):
        self.vop2_instr('lshlrev' if ldir else 'lshrrev', dtype, dest, src0, src1, **kwargs)

    def v_mask(self, dest, src, subgrp_sz, dtype='b32', **kwargs):
        self.vop2_instr('and', dtype, dest, src, subgrp_sz, **kwargs)

    def v_lshl(self, dest, src0, src1, dtype='b32', **kwargs):
        self.v_lsh(dest, src0, src1, dtype=dtype, ldir=True, **kwargs)

    def v_lshr(self, dest, src0, src1, dtype='b32', **kwargs):
        self.v_lsh(dest, src0, src1, dtype=dtype, ldir=False, **kwargs)

    def v_mov(self, dest, src, dtype='b32', **kwargs):
        self.vop1_instr('mov', dtype, dest, src, **kwargs)

    def v_add(self, dest, src0, src1, carry_out=False, dtype='i32', **kwargs):
        if carry_out == False:
            self.vop2_instr('add', dtype, dest, src0, src1, **kwargs)
        else:
            dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
            self.write_line('v_add_co_%s\t%s, vcc, %s, %s' % (dtype, dest, src0,
                src1), **kwargs)

    def v_mul(self, dest, src0, src1, dtype='i32', **kwargs):
        self.vop2_instr('mul_lo', dtype, dest, src0, src1, **kwargs)

    def v_add_lshl(self, dest, src0, src1, src2, dtype='u32', **kwargs):
        self.vop3_instr('add_lshl', dtype, dest, src0, src1, src2)

    def set_lds_addr(self, addr, **kwargs):
        self.s_mov('m0', addr, tab=1, nl=True, **kwargs)

    def read_hwreg(self, dest, src, **kwargs):
        self.sop1_sopk_instr('getreg', 'b32', dest, 'hwreg(' + src + ')', **kwargs)

    def vgpr2sgpr(self, dest, src, **kwargs):
        self.vop1_instr('readfirstlane', 'b32', dest, src, **kwargs)

    def label(self, s, **kwargs):
        self.write_line(s + ":", tab=0, **kwargs)

    def buffer_load(self, dest, off, src_desc, dw=1, lds=0, offset=None, **kwargs):
        dest, off, src_desc = reg_str(dest), reg_str(off), reg_str(src_desc, end_off=3)
        s = 'buffer_load_dword%s %s, %s, %s, %s' % ('x' + str(dw) if dw > 1 else '',
                dest, off, src_desc, '0 offen:1 lds:%d offset:%s' % (lds, offset))
        self.write_line(s, **kwargs)

    def cmp_jmp(self, label, var, val, eq=True, **kwargs):
        self.s_cmp(var, val, **kwargs)
        self.s_cbranch(label, eq, **kwargs)

    def end_pgm(self, **kwargs):
        self.write_line('s_endpgm', **kwargs)

    def cvt2byte(self, var, **kwargs):
        self.v_lshl(var, 1, var, **kwargs)

    def for_loop(self, loops, func_list, start=0, step=1, idxs='i,j,k,l,m,n', tab=1, nl=True):
        loops, func_list = listify(loops), listify(func_list)
        idxs = idxs.split(',')
        for i, k in enumerate(loops):
            idx = idxs[i]
            self.write_line('for var %s = %d; %s < %d; %s += %d' % (idx, start, idx,
                k * step, idx, step), tab=tab)
            tab += 1
        for o in func_list: o(tab=tab+1)
        for i in range(len(loops)):
            tab -= 1
            if tab <= 0: break
            self.write_line('end', tab=tab)
        if nl: self.empty_line()

    def v_accvgpr(self, dest, src0, src1, itype='read', **kwargs):
        dest, src0, src1 = reg_str(dest), reg_str(src0), reg_str(src1)
        self.write_line('v_accvgpr_%s\t%s, %s, %s' % (itype, dest, src0, src1), **kwargs)

    def ds_read(self, dest, src, off, dtype='b64', **kwargs):
        dest, src = reg_str(dest), reg_str(src)
        self.write_line('ds_read_%s\t%s, %s offset:%s' % (dtype, dest, src, off), **kwargs)

    def v_mfma(self, dest, src0, src1, src2, dtype='f32_32x32x8f16', **kwargs):
        dest, src0, src1, src2 = reg_str(dest), reg_str(src0), reg_str(src1), reg_str(src2)
        self.write_line('v_mfma_%s\t%s, %s, %s, %s' % (dtype, dest, src0, src1, src2), **kwargs)

    def unroll(self, label_name, cb, cnt='sgprLoopCounters', total_sz='sgprSizesSum', k=32, end=0, step=1):
        self.s_lshr(cnt, total_sz, to_shift_bit(k))
        self.s_sub(cnt, 0, cnt, nl=True)
        self.label(label_name)
        cb()
        self.s_add(cnt, step, cnt, dtype='u32')
        self.s_cmp(cnt, end, dtype='i32')
        self.s_cbranch(label_name, eq=False)
        self.empty_line()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.description = "Replacement kernel generator"
    parser.add_argument("-f", "--config", type=str, help='specify config file path')
    parser.add_argument("-o", "--output", type=str, help='specify output file path')
    args = parser.parse_args()

    if not args.config:
        print('No config file specified, please use "--help" for more details.')
        exit(-1)

    if not args.output:
        out_fpath = Path(args.config).stem + '.sp3'

    conf = json.load(open(args.config, 'r'))
    with open(out_fpath, 'w') as fp:
        writer = GFX9Writer(fp)
        def_vars(conf, writer)
        mat_a = Data(conf, writer, 'A')
        mat_b = Data(conf, writer, 'B')
        #mat_c = Data(conf, writer, 'C')
        def_header(conf, writer)
        def_fetch(conf, writer, mat_a, mat_b)
        def_mac(conf, writer, mat_a, mat_b)
        def_footer(conf, writer)

    print("[Output]: %s" % out_fpath)

