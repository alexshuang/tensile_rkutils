#!/usr/bin/env python3


import argparse
import json
import os
import pdb
#import numpy as np
#import pandas as pd
from pathlib import Path
from functools import partial

cur_tab = 0


def get_max_dim_size(problem_sizes):
    max_size = 0
    for p in problem_sizes:
        for o in p:
            if max_size < o:
                max_size = o
    return max_size


def do_perf(problem_sizes, thory_gflops):
    max_dim_size = get_max_dim_size(problem_sizes)
    kernel, m, n, c, k, gflops, efficiency = [], [], [], [], [], [], []
    for p in problem_sizes:
        print("pef problem size: " + ', '.join(str(o) for o in p))
        m_, n_, c_, k_ = p[:4]
        ps_cmd = "sed -i \'/.*problemSizes\[/,/}};/s/{.*}};/{" + ', '.join(str(o) for o in p) + "}};/g\' ../source/ClientParameters.h"
        ms_cmd = "sed -i \'s/\(.*maxSize. = \).*/\\1" + str(max_dim_size**2) + ";/g\' ../source/ClientParameters.h"
        cc_cmd = "cmake --build . --config Release -- -j 8"
        perf_cmd = "./client --platform-idx 0 --device-idx 0 --init-alpha 1 --init-beta 0 --init-d 0 --init-c 0 --init-a 3 --init-b 3 --c-equal-d 1 --print-valids 0 --print-max 4 --num-benchmarks 20 --num-elements-to-validate 0 --num-enqueues-per-sync 1 --num-syncs-per-benchmark 1 --use-gpu-timer 1 --sleep-percent 200 --benchmark-solutions 0"
        m.append(m_)
        n.append(n_)
        c.append(c_)
        k.append(k_)
        ret = os.system(ps_cmd)
        if ret != 0:
            print("ERROR: Fail to set problem size: " + ps_cmd)
            exit(ret)
        ret = os.system(ms_cmd)
        if ret != 0:
            print("ERROR: Fail to set maxSize of A/B/C/D: " + ms_cmd)
            exit(ret)
        ret = os.system(cc_cmd)
        if ret != 0:
            exit(ret)
        gflops_ = []
        kernel_name = None
        for _ in range(1):
            res = os.popen(perf_cmd).readlines()[-1].split(' ')
            gflops_.append(float(res[1]))
            if kernel_name == None:
                kernel_name = res[-1].strip()
        gflops_max = max(gflops_)
        print(gflops_)
        print(gflops_max)
        gflops.append(gflops_max)
        efficiency.append(gflops_max / float(thory_gflops) * 100)
        kernel.append(kernel_name)
    return (kernel, m, n, c, k, gflops, efficiency)


def save_file(data):
    kernel, m, n, c, k, gflops, efficiency = data
    df = pd.DataFrame()
    #df['KernelName'] = np.array(kernel)
    df['M'] = np.array(m)
    df['N'] = np.array(n)
    df['C'] = np.array(c)
    df['K'] = np.array(k)
    df['GFlops'] = np.array(gflops)
    df['Efficiency'] = np.array(efficiency)
    fname = kernel[0] + '.csv'
    print("perf resoult save as " + fname)
    df.to_csv(fname, index=False)


def write_line(fp, s='', cmt='', tab=0):
    pre_s = '  ' * tab
    if cmt != '':
        if not cmt.startswith('//'):
            cmt = '// ' + cmt
        cmt = '\t\t' + cmt
    fp.write(pre_s + s + cmt + '\n')


def write_comments(fp, s, bar=False, bar_len=40, nl=False, tab=0):
    pre_s = '  ' * tab
    if bar:
        bar_s = pre_s + '/' + '*' * bar_len + '/\n'
    s = pre_s + '/*' + s + '*/\n' if bar else pre_s + '// ' + s + '\n'
    if bar:
        fp.write(bar_s)
    fp.write(s)
    if bar:
        fp.write(bar_s)
    if nl:
        fp.write('\n')


def def_var(fp, name, val, cmt='', nl=False):
    val = str(val)
    write_line(fp, 'var ' + name + ' = ' + val, cmt)
    if nl:
        write_line(fp)


def def_regs(conf, fp):
    for k in ['sregs', 'vregs']:
        write_line(fp, "// %s define" % k)
        for k, v in conf[k].items():
            def_var(fp, k, v)
        write_line(fp)

    write_comments(fp, '2GB limit - set offsets to -1 to exceed this and clamp')
    def_var(fp, 'BufferLimit', 0x80000000, nl=True)
    write_comments(fp, 'Bits 127:96 of SRD.  Set DataFormat = 32 bit')
    def_var(fp, 'Srd127_96', 0x0020000, nl=True)
    def_var(fp, 'roundMaskVal', 0xffff0000, nl=True)


def def_lds_vars(conf, fp):
    # calc index per thread
    pad = conf['mfma']['pad']
    mt_h = conf['mt']['h']
    mt_w = conf['mt']['w']
    simd = conf['mfma']['simd']
    a_per_wr = 256 + pad
    lvca = 32 / (conf['glvw'] * 2)
    rows_per_wave = mt_h / simd
    a_vw = rows_per_wave / (64 / lvca)
    a_per_wave = a_per_wr * a_vw
    a_per_wg = a_per_wave * simd
    b_per_wr = 256 + pad
    lvcb = 32 / (conf['glvw'] * 2)
    cols_per_wave = mt_w / simd
    b_vw = cols_per_wave / (64 / lvcb)
    b_per_wave = b_per_wr * b_vw
    b_per_wg = b_per_wave * simd

    write_line(fp, "// lds vars define")
    def_var(fp, 'varlds_pad', pad)
    def_var(fp, 'varlds_Asize_per_wr', a_per_wr, '256 + varlds_pad')
    def_var(fp, 'varlds_Asize_per_wave', 'varlds_Asize_per_wr * %d' % a_vw, 'vw == %d' % a_vw)
    def_var(fp, 'varlds_Asize_per_wg', 'varlds_Asize_per_wave * %d' % simd)
    write_line(fp)
    def_var(fp, 'varlds_Bsize_per_wr', b_per_wr, '256 + varlds_pad')
    def_var(fp, 'varlds_Bsize_per_wave', 'varlds_Bsize_per_wr * %d' % b_vw, 'vw == %d' % b_vw)
    def_var(fp, 'varlds_Bsize_per_wg', 'varlds_Bsize_per_wave * %d' % simd)
    write_line(fp)
    def_var(fp, 'varA_lds_base_addr', 0)
    def_var(fp, 'varB_lds_base_addr', 'varA_lds_base_addr + varlds_Asize_per_wg * 2')
    write_line(fp)

    conf['lvca'] = lvca
    conf['lvcb'] = lvcb
    conf['a_vw'] = a_vw
    conf['b_vw'] = b_vw
    conf['varlds_Asize_per_wr'] = a_per_wr
    conf['varlds_Asize_per_wave'] = a_per_wave
    conf['varlds_Asize_per_wg'] = a_per_wg
    conf['varlds_Bsize_per_wr'] = b_per_wr
    conf['varlds_Bsize_per_wave'] = b_per_wave
    conf['varlds_Bsize_per_wg'] = b_per_wg


def def_start(conf, fp):
    write_line(fp, '\nshader main')
    write_line(fp, 'user_sgpr_count(14)', tab=1)
    write_line(fp, 'tgid_x_en(1)', tab=1)
    write_line(fp, 'tgid_y_en(1)', tab=1)
    write_line(fp, 'tgid_z_en(1)', tab=1)
    write_line(fp, 'tidig_comp_cnt(2)', tab=1)
    write_line(fp)


def def_end(conf, fp):
    write_line(fp, 'label_end:')
    write_line(fp, 's_waitcnt 0', tab=1)
    write_line(fp, 's_endpgm', tab=1)
    write_line(fp)
    write_line(fp, 'end')
    write_line(fp)


def s_buff_load(fp, dest, base, off, dw=1):
    s = 's_load_dword%s %s, %s, 0x%x' % ('x' + str(dw) if dw > 1 else '',
            reg_str(dest, end_off=3), reg_str(base, end_off=1), off)
    write_line(fp, s, tab=1)


def buff_load(fp, dest, base, off, dw=4):
    s = 'load_dword%s v[%s%s], v[%s:%s+3], 0x%x' % ('x' + str(dw) if dw > 1 else '',
            dest, ':%s+%d' % (dest, dw - 1) if dw > 1 else '',
            base, base, off)
    write_line(fp, s, tab=1)


def sv_buff_load(fp, reg, dest, src, off, dw=4, lds=0):
    s = '%s_load_dword%s %s[%s%s], %s[%s:%s+3]' % (reg, 'x' + str(dw) if dw > 1 else '',
            reg, dest, ':%s+%d' % (dest, dw - 1) if dw > 1 else '',
            reg, src, src)
    off_s = ', 0 offen:1 lds:%d offset:%d' % (lds, off) if reg == 'v' else ', 0x%x' % off
    write_line(fp, s + off_s, tab=1)


def reg_str(s, start_off=None, end_off=None):
    if not s.startswith('vgpr') and not s.startswith('sgpr'):
        return 's[' + s + ']'
    if start_off:
        s = s + '+' + start_off 
    if end_off:
        s = s + ':%s+%d' % (s, end_off)
    return 'v[' + s + ']' if s.startswith('vgpr') else 's[' + s + ']'


# load kernel args to sgpr
def load_karg(conf, fp, var, dw=1):
    s_buff_load(fp, var, 'sgprKernArgAddress', conf['kargs'][var], dw=dw)
    return var


def get_tid_x(fp, var, tab=1):
    write_line(fp, 'v_mov_b32\t%s, v0' % reg_str(var), tab=tab)
    return var


def get_tid_wave(fp, var, tab=1):
    write_line(fp, 'v_and_b32\t%s, 0x3f, v0' % reg_str(var), tab=tab)
    return var


def camp_lds(fp, sz, tab=1):
    write_line(fp, 'v_mov_b32\tm0, 0x%x' % sz, tab=tab)


def get_wave_front_id(fp, wid, tid, tab=1):
    write_line(fp, 'v_lshrrev_b32\t%s, 6, %s' %
            (reg_str(wid), reg_str(var)), tab=tab)
    return wid


def get_hw_id(fp, simd_id, wave_id, cu_id=None, tab=1):
    #HW_ID_REG
    #bit[0-3] #waveId
    #bit[5-4] #simdId
    #bit[11-8] #CuId
    write_line(fp, 's_getreg_b32\ts[hw_id], hwreg(HW_REG_HW_ID)', tab=tab)
    write_line(fp, 'v_and_b32\tv4, 0x30, s[hw_id]', tab=tab)
    write_line(fp, 'v_lshrrev_b32\t%s, 4, v4' % reg_str(simd_id), tab=tab)
    write_line(fp, 'v_and_b32\t%s, 0xf, s[hw_id]' % reg_str(wave_id), tab=tab)
    return (simd_id, wave_id)


def get_threadIds(conf, fp):
    #vgprSerial    holds threadIdx
    #vgprSerial+1  holds WaveFrontId (0-63)
    #vgprSerial+2  holds threadIdy  (simd= 0,1,2,3)
    #vgprSerial+3  holds threadIdZ  (wave0 =0 wave1 = 1)
    tid = get_tid_x(fp, 'vgprSerial')
    tid_of_wave = get_tid_wave(fp, 'vgprSerial+1')
    #wfid = get_wave_front_id(fp, 'v2', tid) # 0-3
    (simd_id, wave_id) = get_hw_id(fp, 'vgprSerial+2', 'vgprSerial+3') 

    conf['tid'] = tid
    conf['tid_of_wave'] = tid_of_wave
    conf['simd_id'] = simd_id
    conf['wave_id'] = wave_id

    write_line(fp)


def vgpr2sgpr(fp, dest, src, tab=1):
    write_line(fp, 'v_readfirstlane_b32\t%s, %s' % (reg_str(dest), reg_str(src)), tab=tab)


def create_branch(fp, label, var, val, tab=1, eq=False):
    tmp = 'hw_id+1'
    wid = vgpr2sgpr(fp, tmp, var)
    write_line(fp, 's_cmp_eq_u32\t%s, %d' % (reg_str(tmp), val), tab=tab)
    cmp_instr = 's_cbranch_scc1' if eq else 's_cbranch_scc0'
    write_line(fp, '%s\t%s' % (cmp_instr, label), tab=tab)
    write_line(fp)


def wait_lgkmcnt(fp, cnt, tab=1):
    write_line(fp, 's_waitcnt\tlgkmcnt(%d)' % cnt, tab=tab)
    write_line(fp)


def def_fetch(conf, fp):
    # load A/B address, stridesA/B, sgprTensor2dSizeA/B, size L
    addrA = load_karg(conf, fp, 'sgprAddressA', 4)
    strideA = load_karg(conf, fp, 'sgprStridesA', 4)
    t2d_sizeA = load_karg(conf, fp, 'sgprTensor2dSizeA', 4)
    size_sum = load_karg(conf, fp, 'sgprSizesSum')
    addrB = addrA + '+2'
    strideB = strideA + '+2'
    t2d_sizeB = t2d_sizeA + '+2'
    write_line(fp)

    # set lds max size to 0x3000
    camp_lds(fp, 0x3000)

    # git threadIdx/y/z, waveid, simdid...
    get_threadIds(conf, fp)

    create_branch(fp, 'wave0_MAC', 'vgprSerial+3', 1)

    # wait for load kern args
    wait_lgkmcnt(fp, 0)
    

def init_accvgpr(fp, i, tab=1):
    write_line(fp, 'v_accvgpr_write\t%s, 0, 0' % reg_str('vgprAcc', start_off=i), tab=tab)


def for_loop(ends, func_list, start=0, idxs='i,j,k,l,m,n'):
    idxs = idxs.split(',')
    tab = 0
    for i, k in enumerate(ends):
        idx = idxs[i]
        tab += 1
        write_line(fp, 'for var %s = 0; %s < %d; %s++' % (idx, idx, k, idx), tab=tab)
        for o in func_list: o(tab=tab+1)
        write_line(fp, 'end', tab=tab)
    write_line(fp)


def def_mac(conf, fp):
    write_line(fp, 'wave0_MAC:')
    write_line(fp)
    write_comments(fp, 'hide all memory  load (kern args load) latency with ACC VGPR initialization', tab=1)
    for_loop([32], [partial(init_accvgpr, fp, 'i')])


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.description = "Replacement kernel generator"
    parser.add_argument("-f", "--config", type=str, help='specify config file path')
    parser.add_argument("-o", "--output", type=str, help='specify output file path')
    args = parser.parse_args()

    if not args.config:
        print('No config file specified, please use "--help" for more details.')
        exit(-1)

    if not args.output:
        out_fpath = Path(args.config).stem + '.sp3'

    conf = json.load(open(args.config, 'r'))
    with open(out_fpath, 'w') as fp:
        def_regs(conf, fp)
        def_lds_vars(conf, fp)
        def_start(conf, fp)
        def_fetch(conf, fp)
        def_mac(conf, fp)
        def_end(conf, fp)

